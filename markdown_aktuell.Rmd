---
title: "Energiewende in Sazlburg - Potenziale Solaranlagen"
author: "Timothy Sung"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```

# Einleitung

Klimawandel Hintergrund

Seit 1992 mit der Konferenz der Vereinten Nationen über Umwelt und Entwicklung in Rio de Janeiro steht die nachhaltige Entwicklung in allen politischen Bereichen ganz oben auf der Agenda und entwickelte sich zu einem allgemeinen Ziel des 21. Jahrhundert. Eine große Herausforderung bei der Erreichung einer nachhaltigen Welt ist der steigende Energiebedarf und die damit verbundenen zunehmenden Umweltprobleme (Wenz, 2022). Zu Problemen wie Luftverschmutzung und Erderwärmung führt ein erhöhter Verbrauch von fossilen Brennstoffe, die nur Deckung eines wachsenden Energiebedarf verwendet werden (Mokarram et al., 2020; Winiwarter et al., 2018).  Um diese Herausforderung zu meistern, wird eine Energiewende in Richtung erneuerbare Energie gebraucht. Dieser Schritt stellt eine große Umstellung der Energiesysteme weg von fossilen Brennstoffe dar und könnte eine große und radikale Transformation der Wirtschaftsweise und Energiesystem einläuten (Wenz, 2022).  

Der Klimawandel wird auch von der Energiegewinnung durch nicht erneuerbare Energiequellen verstärkt, was die nachhaltige Entwicklung bedroht. Wenn keine Klimaschutzmaßnahmen ergriffen und Strategien zur Anpassung an den Klimawandel befolgt werden, werden die gesundheitlichen und wirtschaftlichen Folgen einer stärkeren Erderwärmung heftiger und der Klimawandel nicht gemildert (Decker, 2019). Der Energiesektor bietet doch die größten Chance, Klimaschutzmaßnahmen umzusetzen, da die Dekarbonisierung des Energiesektors schneller erfolgen kann als in anderen Industriebereichen (Riahi, 2023). Das ist auch der Grund, warum der IPCC (Intergovernmental Panel on Climate Change) der Rolle der erneuerbaren Energien bei der Bekämpfung des Klimawandels eine große Bedeutung beimisst. Alle von der IPCC entwickelten Klimaszenarien (Repräsentative Konzentrationspfade - engl. Representative Concentration Pathways – RCPs), die den Temperaturanstieg bis 2100 gegenüber dem vorindustriellen Niveau auf 2 Grad begrenzt, sprich RCP 4.5, 2.6 und 1.9, sehen eine Transformation der Energieversorgung vor, wobei die Erzeugung von Energie aus erneuerbaren Quellen erheblich erhöht wird, damit fast alle Strom bis 2050 von kohlenstofffreie oder -arme Quellen geliefert wird (Calvin et al., 2023; Rogelj et al., 2018). Bei RCP 1.9, der mit dem 1,5-Grad-Ziel vereinbar wäre, findet die Ersetzung von fossiler mit erneuerbarer Energie umso zügiger statt (Rogelj et al., 2018). Es ist schon zu sehen, dass sich die Welt in diese Richtung bewegt. 2014 war das erste Jahr, in dem die globale Wirtschaft wuchs, während der Ausstoß klimaschädlicher Treibhausgasse sank (Alt, 2021). Nichtsdestotrotz muss erneuerbare Quellen einen noch höheren Anteil des Energiemixes ausmachen und die Umstellung auf erneuerbare Quellen beschleunigt werden, bevor eine Wirkung der Klimaschutzmaßnahmen zur Bekämpfung des Klimawandels zu spüren ist und die Energiewende gelingen kann.

## Gesellschaftliche Faktoren der Energiewende

Die Energiewende wird von verschiedenen Akteuren beeinflusst, wie beispielsweise der Zivilgesellschaft, politischen Parteien, Medien, Anwohnern und Regierungen (Geels et al., 2017). Bei diesen Gruppen spielen zahlreiche Faktoren, die Aspekte einschließen wie unterschiedliche Überzeugungen, widersprüchliche Werte, konkurrierende Interessen, ungleiche Ressourcen und komplexe soziale Beziehungen (ibid.). Zur Integration von Technologien und Innovationen für die Energiewende in die Gesellschaft braucht man daher die gesellschaftliche Anerkennung von erneuerbaren Energieprojekten (Geels et al., 2017; Pao, 2023; Rowe u. Frewer, 2000; Rogelj et al., 2018). 

Da die grundlegende Transformation des Energiesystems mit einem fundamentalen gesellschaftlichen Wandel verbunden werden könnte, muss die Bevölkerung auch ins Boot geholt werden, damit die mit der Energiewende verbundenen Kosten, Risiken und Nutzen fair verteilt werden (Sareen u. Haarstad, 2018). In diesem Zusammenhang spielen die politische Meinungen der Bevölkerung eine Role in der Akzeptanz der Maßnahmen, die zu einer Energiewende beitragen könnten. Deshalb müssen Politik zur Energiewende Rücksicht auf die Belange der breiteren Gesellschaft und deren verschieden Gruppen nehmen, andernfalls wird die Akzeptanz von Klimamaßnahmen erschwert (Beierle, 1998; Gingrich, 2023; Schneider, 2023). 

## Solarenergie und klimapolitische Maßnahmen

Als eine Klimaschutzmaßnahme zeigt sich der Ausbau von Solaranlagen viel Potenzial. Zwischen 2000 und 2021 wurden ein große Anstieg in der Erzeugung von Solarenergie erfahren, wobei sie verhundertfachte. In dem letzten Jahrzehnt sanken die Kosten zu Solarenergie deutlich, was den Ausbau von Solaranlage in vielen Regionen ermöglicht hat (Calvin et al., 2023; Rogelj et al., 2018). Außerdem werden Solarmodule immer effizienter (Mierzwiak u. Calka, 2017). Daher stellt die Solarenergie einen effektiven Teil des Wegs zur Eindämmung des Klimawandels dar. Wenn Solarenergieprojekten erfolgreich eingesetzt werden, wäre es möglich Emissionen zu reduzieren und Energie sauber zu erzeugen (Mokarram et al., 2020), die die soziotechnische Transformation vorantrieben kann. Infolge dessen wird die Verletzlichkeit der Gesellschaft zu steinigenden Temperaturen verringert, wenn die Umstellung auf Solarenergie und erneuerbare Energie schnell genug stattfindet. 

Aufgrund der günstigen wirtschaftlichen und technologischen Entwicklungen im Bereich Solarenergie, stiegt die Attraktivität der Energieerzeugung von Solarquellen. Auf der Seite der Politik wird Solarenergie durch Gesetzte und Strategien zunehmend gefördert. Viele Entscheidungsträger*innen erkennen die entscheidende Rolle des Übergangs zu nachhaltigeren Energiesystemen und die Bedeutung von Solarenergie als Teil von diesem Übergang (Kowalski, 2010). In der EU trat erneuerbare Energie in 2009 in den Vordergrund, als die EU die Richtlinie 2009/28/EG des Europäischen Parlaments und des Rates erließ. Damit wurde eines der Hauptziele der EU zur Förderung sauberer Energie definiert, wobei für 2020 und 2030 Ziele zur Reduzierung der Stromerzeugung aus konventionellen Quellen und zur Nutzung erneuerbarer Energien festgelegt wurden. In dem neuen “Europäischen Klimagesetz” werden diese Vorhaben verschärft und nun sind die EU-Länder dazu verpflichtet, Klimaneutralität bis 2050 zu erreichen (Verordnung (EU) 2021/1119 des Europäischen Parlaments und des Rates). Damit es ihnen bei diesen Aufgaben gelingt, braucht es die konkrete Umsetzung auf der nationalen Ebene.

In Österreich trat das Erneuerbaren-Ausbau-Gesetz in 2021 in Kraft (BGBL I Nr.150/2021), die genauso wie das Europäische Klimagesetz Klimaneutralität anstrebt. In den österreichischen Gesetz wird es schon vorgesehen, dass Österreich seine Versorgung mit Strom bis 2030 komplett aus erneuerbaren Quellen gewinnt. Um dieses Ziel zu erreichen, ist eine Erhöhung der Photovoltaikerzeugung um 11 THw bis zum Jahr 2030 geplant, wobei der Ausbau von Solaranlagen auf Freiflächen 5,7 TWh bringen sollte (Fechner, 2021; Kerber, 2022). Das heißt, dass Freiflächen das größte Potenzial für eine Steigerung der Solarenergieerzeugung. Obwohl dieses Potenzial besteht, findet derzeit der Wachstum in Solarenergie in Österreich sehr langsam statt und das Potenzial bleibt noch unausgeschöpft (Wenz, 2022). 

Die Verantwortung für den Ausbau der Solaranlagen liegt nicht allein bei der Bundesregierung. Dank dem föderalem System Österreichs treffen gemeinsam der Bund und die Länder Entscheidungen über die Energiepolitik (ibid.). Deswegen ist Austausch zwischen Bund und Ländern zu diesem Thema erforderlich. Während der Bund das Gesamtbild im Blick hat und die strategische Richtung steuert, sind die Länder für die Bereiche zuständig, die den eigentlichen Ausbau betrifft. Dazu gehören Raumplanung, Bauplanung, Regionalplanung und Natur- und Landschaftsschutz, die alle regeln, ob eine neue Anlage gebaut werden darf (Bußjäger, 2016). Da die Bundesländer die Kontrolle über die Raumplanungsmechanismen haben, ist es sinnvoll, sich auf diese Ebene zu konzentrieren, wenn man das Solarpotenzial eines bestimmten Gebiets in Österreich analysieren möchte.

Auf der Landesebene ist Salzburg eines der Bundesländer, das schon eine langfristige Strategie zur Bekämpfung des Klimawandels erstellte, die Klima- und Energiestrategie SALZBURG 2050 (Land Salzburg, 2024). Diese wurde in vier Etappen unterteilt und gerade befindet sie sich beim Masterplan Klima + Energie 2030 (Land Salzburg, 2021; siehe Abb. 1). Das Bundesland strebt nicht nur das Ziel der Klimaneutralität bis 2050 an, sondern plant auch, bis 2030 den gesamten Strombedarf aus erneuerbaren Quellen zu decken, was die Klimaziele des Bundes widerspiegelt. Da die Solarenergie angesichts des Widerstands gegen Windparks und der Erschöpfung des Potenzials der Wasserkraft in diesem Land dem Bundesland den vielversprechendsten Weg bietet (Kettner et al, 2024; Kerber, 2022), seinen Beitrag zu der Energiewende in Österreich zu leisten, biete sich das Land an, sein Solarenergiepotenzial näherer zu analysieren. Mit einer räumliche Analyse des Landes kann es festgestellt werden, wie das Solarenergiepotenzial des Landes Salzburg aus einem räumlichen und raumplanerischen Standpunkt ausgeschöpft werden kann. 

![Abbildung 1: Klima- und Energiestrategie SALZBURG 2050 (Land Salzburg, 2021)](offline_files/masterplan_klima_bild.png)
Abbildung 1: Klima- und Energiestrategie SALZBURG 2050 (Land Salzburg, 2021)

# Hypothesen

Um das Solarpotenzial Salzburgs und die räumliche Verteilung potenzialer Solaranlagen zu erforschen, wurden zwei Hypothesen entwickelt:

1. Je großer der Anteil von bewohntem Raum es in einer Gemeinde gibt, desto weniger geeignete Fläche gibt es für Solaranlagen
2. In Gemeinden mit den höchsten Grünlandanteilen ist die Fläche größer, die sich für die Errichtung der Solaranlagen eignet

# Kriterien

Wenn eine Solaranlage gebaut wird, müssen Aspekte wie Maximalisierung der Energiegewnninung, Nähe an Stromnetzinfrastruktur, ökologische Folgen und Baugenehmigungen berücksichtigt werden. Anhand davon werden die Kriterienkataloge, die in Tabelle 1 umgerissen wird, in dieser Analyse angewandt. 

<style>
    table {
        border-collapse: collapse;
        width: 100%;
    }

    th, td {
        border: 0.5px solid black;
        padding: 8px;
        text-align: left;
    }

    th:first-child, td:first-child {
        border-right: 2px solid black;
    }

    tr:first-child td {
        border-top: 2px solid black;
    }

    tr:nth-child(2) td{
        border-top: 2px dashed black;
    }
    tr:nth-child(9) td:first-child {
    border-top: 2px dashed black;
    border-bottom: 2px dashed black;
    }
    
    tr:nth-child(9) td:last-child {
    border-top: 2px dashed black;
    border-bottom: 2px dashed black;
    }
    tr:nth-child(1) td {
        border-right: none;
        border-right: 0.5px solid black;
    }
    tr:nth-child(9) td {
        border-right: none;
        border-right: 0.5px solid black;
    } 
    
    tr:nth-child(1) td:nth-child(2) {
        border: none; /* Remove borders for the second column in the second row */
    }
    tr:nth-child(9) td:nth-child(2) {
        border: none; /* Remove borders for the second column in the second row */
    }
    
</style>

Tabelle 1: Kriterien berücksichtigt für die Standortwahl von PV-Anlagen (Adaptiert von Kereush & Perovych, 2017)
<table>
  <thead>
    <tr>
      <th>Kriterien</th>
      <th>Voraussetzung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="2"><i>Evaluierungskriterien</i></td>
      <td></td>
    </tr>
    <tr>
      <td>Ausreichende Solareinstrahlung</td>
      <td>Minimum 1100 kWh/m<sup>2</sup>/Jahr</td>
    </tr>
    <tr>
      <td>Hangneigung</td>
      <td>&lt; 15&deg;</td>
    </tr>
    <tr>
      <td>Hangausrichtung</td>
      <td>110-200&deg; (Südost, Süd, teils Südwest) <br>Wenn die Hangneigung unter 3.5&deg; ist, kann die Anlage in irgendwelche Richtung ausgerichtet werden</td>
    </tr>
    <tr>
      <td>Nähe zu bewohnten Gebieten</td>
      <td>&lt; 2500 m</td>
    </tr>
    <tr>
      <td>Nähe zu Betrieben</td>
      <td>&lt; 3500 m</td>
    </tr>
    <tr>
      <td>Nähe zum Straßennetz</td>
      <td>&lt; 500 m</td>
    </tr>
    <tr>
      <td>Nähe zu Wohnegebieten</td>
      <td>\> 500 m</td>
    </tr>
    <tr>
      <td colspan="2"><i>Auschlusskriterien</i></td>
      <td></td>
    </tr>
    <tr>
      <td>Landabdeckung</td>
      <td>• Frei von Bergen, Wäldern, Gewässern, Gebäuden und Feuchtgebieten <br>• Bevorzugt: Grünland und Agrarfläche</td>
    </tr>
    <tr>
      <td>Schutzgebiete</td>
      <td>Schutzgebiete ausgewiesen vom Land, Bund und EU</td>
    </tr>
    <tr>
      <td>Höhenlage</td>
      <td>\> 1500 m</td>
    </tr>
    <tr>
      <td>Bahnstrecken</td>
      <td>Darf nicht überschneiden</td>
    </tr>
  </tbody>
</table>


Eine Mindestsolareinstrahlung von 1100 kWh/m^2^/Jahr wird vorausgesetzt, weil eine PV-Anlage typischerweise diese Höhe von Solareinstrahlung braucht, um kostendeckend zu sein (Kereush u. Perovych, 2017). In Bezug auf die Hangneigung der Fläche sollte sie unter 15% bleiben, weil die Errichtung von Solaranlagen an Steillagen Probleme bezüglich Erosion, Stabilität des Bodens und hydrologisches System verursachen könnte und ihre Effizienz bei der Absorption der Sonnenstrahlung einschränken kann (Arnette u. Zobel, 2011, Castillo et al., 2016). Im Idealfall würde die Nähe eine Solaranlage an Stromversorgungsleitung mitberücksichtigen werden, aber in Salzburg gibt es keinen detaillierten öffentlich zugänglichen Datensatz dazu. Es ist empfehlenswert, PV-Anlagen in der Nähe von Gebieten mit hohem Strombedarf, wie Städten, Dörfern oder Unternehmen, zu errichten. Dadurch wird die Entfernung, die der Strom zurücklegen muss, minimiert und die damit verbundenen Leitungsverluste und Übertragungskosten reduziert (Arán-Carrión et al., 2008). Straßen sind wesentlich Straßen sind für den Transport der für den Bau von Solaranlagen benötigten Materialien entscheidend und deshalb sollte sich potenzielle Standorte für Solaranlagen in der Nähe von Straßen befinden. Um das NIMBY (engl: not in my backyard, im Sinne von „nicht in meiner Nachbarschaft”) Problem zu vermeiden, muss auch ein gewisser Abstand von Wohngebieten gehalten werden. Was das Bodenbedeckungspotenzial betrifft, so müssen geeignete Flächen frei von Bergen, Wäldern, Gewässern, Gebäuden, Feuchtgebieten und Überschwemmungsgebieten sein und hat vorzugsweise eine niedrige oder mittlere Gras- oder Strauchvegetation (Kereush u. Perovych, 2017). In Salzburg wurde die Errichtung von Solaranlagen im Grünland mit der Photovoltaik-Kennzeichnungsverordnung (LGBl. Nr. 73/2023), die mit 1. November in Kraft getreten ist. Zudem gibt es derzeit Überlegungen in Österreich, Solaranlagen vermehrt auf Ackerland zu errichten. Um dieser möglichen Entwicklung Rechnung zu tragen, wurde Agrarfläche, einschließlich Ackerland, neben Grünland, in die Liste der geeigneten Landabdeckungstypen für Solaranlagen in dieser Studie aufgenommen. Schutzgebiete wurde wegen den Auflagen, die Entwicklung und Ausbau der Infrastruktur aus Umwelt- und Landschaftsschutzgründen verhindern, als ungeeignet eingestuft und Lagen über 1500 m wurden auch von einer eventuellen Kulisse für Solaranlagen aufgrund der erhöhten Kosten für den Transport von Baumateriellen und Instandhaltung herausgenommen (Kereush u. Perovych, 2017). Außerdem dürfen Flächen für Solaranlagen nicht mit Bahnschienen überschneiden.

# Methoden, Ergebnisse und Analyse

Die statistische und räumliche Analyse für diese Studie wurde mit R durchgeführt. 

## Festlegung von Working Directory und Installation und Laden von Libraries
```{r, eval = TRUE}
# set working directory
setwd("/Volumes/SD_Backup/GIS_Project")
```

```{r install libraries}
# Install the required libraries if not already installed
if (!requireNamespace("tmap", quietly = TRUE)) {
  install.packages("tmap")
}
if (!requireNamespace("raster", quietly = TRUE)) {
  install.packages("raster")
}
if (!requireNamespace("terra", quietly = TRUE)) {
  install.packages("terra")
}
if (!requireNamespace("stars", quietly = TRUE)) {
  install.packages("stars")
}
if (!requireNamespace("sp", quietly = TRUE)) {
  install.packages("sp")
}
if (!requireNamespace("sf", quietly = TRUE)) {
  install.packages("sf")
}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}
if (!requireNamespace("janitor", quietly = TRUE)) {
  install.packages("janitor")
}
if (!requireNamespace("leaflet", quietly = TRUE)) {
  install.packages("leaflet")
}
if (!requireNamespace("leaflet.extras", quietly = TRUE)) {
  install.packages("leaflet.extras")
}
if (!requireNamespace("cluster", quietly = TRUE)) {
  install.packages("cluster")
}
if (!requireNamespace("readr", quietly = TRUE)) {
  install.packages("readr")
}
if (!requireNamespace("factoextra", quietly = TRUE)) {
  install.packages("factoextra")
}
if (!requireNamespace("stringr", quietly = TRUE)) {
  install.packages("stringr")
}
if (!requireNamespace("spdep", quietly = TRUE)) {
  install.packages("spdep")
}
if (!requireNamespace("units", quietly = TRUE)) {
  install.packages("units")
}
if (!requireNamespace("RColorBrewer", quietly = TRUE)) {
  install.packages("RColorBrewer")
}
if (!requireNamespace("basemaps", quietly = TRUE)) {
  install.packages("basemaps")
}
if (!requireNamespace("tmaptools", quietly = TRUE)) {
  install.packages("tmaptools")
}
if (!requireNamespace("nominatimlite", quietly = TRUE)) {
  install.packages("nominatimlite")
}
if (!requireNamespace("knitr", quietly = TRUE)) {
  install.packages("knitr")
}
if (!requireNamespace("kableExtra", quietly = TRUE)) {
  install.packages("kableExtra")
}
if (!requireNamespace("extrafont", quietly = TRUE)) {
  install.packages("extrafont")
}
if (!requireNamespace("tinytex", quietly = TRUE)) {
  install.packages("tinytex")
}
if (!requireNamespace("leaflegend", quietly = TRUE)) {
  install.packages("leaflegend")
}
```


```{r load libraries, eval=TRUE}
library(tmap)
library(raster)
library(terra)
library(stars)
library(sp)
library(sf)
library(tidyverse)
library(janitor)
library(leaflet)
library(leaflet.extras)
library(cluster)
library(readr)
library(factoextra)
library(stringr)
library(spdep)
library(units)
library(RColorBrewer)
library(basemaps)
library(tmaptools)
library(nominatimlite)
library(knitr)
library(kableExtra)
library(extrafont)
library(tinytex)
library(leaflegend)
```

## Dateneinlesen

In diesem Schritt wurden die benötigten Daten zur Solareinstrahlung, Verwaltungsgrenzen, Bevölkerung, den Landtagswahlergebnissen 2023, der Landabdeckung, Zonierung, topographischen Merkmalen und Schutzgebieten eingelesen. In manchen Fällen werden sie kombiniert und das Koordinatensystem auf EPSG:31258 festgelegt. Dieses Koordinatensystem wird für die Analyse und Erstellung der Karten verwendet, mit Ausnahme der interaktiven Leaflet-Karten.

```{r}
#### ----------- Data Download and CRS Check and Transformation ----------- ####
# read in solar potential data ----
solar_raw <- rast("offline_files/Solarpot/solarpot_31258.tif")
```

```{r, eval = TRUE, results = FALSE}
# download data on municipality borders and populations, and create state border polygon  ----
# download raw data on municipality borders 
gem_grenz_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/ESRI_SHAPE/Gemeindegrenzen.shp")

# download data on municipality populations ----
pop_raw <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Bev_2023_nach_Katastralgemeinden.csv",
                    # skip first row so that columns names are the headers
                    skip = 1) 

# create a polygon with the boundaries of Sazlburg state
bundesland <- gem_grenz_raw %>%
  # generate IDs for grouping
  mutate(merge_id = 1) %>% 
  group_by(merge_id) %>%
  summarise(geometry = sf::st_union(geometry)) %>%
  ungroup()
```

```{r, eval = TRUE, results = FALSE}
# read in data on the Landtagswahl 2023 ----
ltw_raw <- read_csv2("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master//LTW-2023.csv") #only first page of orignal data saved as csv

```

```{r}
# read in data on land cover, combine layers and amend CRS ----
lc_a_raw <- rast("offline_files/land_cover/ESA_WorldCover_10m_2021_v200_N45E012_Map.tif")
lc_b_raw <- rast("offline_files/land_cover/ESA_WorldCover_10m_2021_v200_N48E012_Map.tif")

# combine raster layers
lc_comb <- terra::merge(lc_a_raw, lc_b_raw)

# transform CRS to that of lc_comb - quicker than reprojecting both rasters
gem_grenz_4326 <- st_transform(gem_grenz_raw, "EPSG:4326") 

# crop lc data to Salzburg bb
lc_comb_sbg_bb <- terra::crop(lc_comb, gem_grenz_4326) 

# transfrom Salzburg boundaries to EPSG: 4326
bundesland_4326 <- st_transform(bundesland, "EPSG:4326") 

# mask lc data to Salzburg
lc_comb_sbg <- terra::mask(lc_comb, bundesland_4326)

# re-project lc_comb_sbg to working CRS
lc_sbg <- project(lc_comb_sbg, "EPSG: 31258")
```

```{r, include = FALSE}
# write out raster to save time on processing
writeRaster(lc_sbg, "daten_zwischenablage/lc_sbg.tif", overwrite = TRUE) 
```

```{r, eval = TRUE, results = FALSE}
# read in data on zoning ----
fl_wid_raw <- st_read("offline_files/Flaechenwidmung/Flaechenwidmung.shp")
```

```{r}
# read in digital surface model (topographical data) ----
dgm <- rast("offline_files/dgm5m/dgm5m.asc")

# convert to working crs of EPSG: 31258 
dgm <- project(dgm, "EPSG:31258")
```

```{r, include=FALSE}
# write out raster
writeRaster(dgm, "daten_zwischenablage/dgm.tif") # write out raster
```

```{r, eval = TRUE, results = FALSE}
#### Load data on protected areas

# download data on FFH sites ----
ffh_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_FFH_RL/Europaschutzgebiete_FFH_RL.shp")

# download data on other Natura 2000 sites ----
natura2000_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_Schutzzonen/Europaschutzgebiete_Schutzzonen.shp")

# download data on SPA sites ----
spa_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_VS_RL/Europaschutzgebiete_VS_RL.shp")

# download data on RAMSAR sites ----
ramsar_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Gebiete_gem_Ramsar_Konvention/Gebiete_gem_Ramsar_Konvention.shp")

# download data on protected landscape features ----
geschuezte_lt_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Geschuetzte_Landschaftsteile/Geschuetzte_Landschaftsteile.shp")

# download data on protected natural features ----
geschuezte_ng_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Geschuetzte_Naturgebilde/Geschuetzte_Naturgebilde.shp")

# download data on landscape protection areas ----
lsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Landschaftsschutzgebiete/Landschaftsschutzgebiete.shp")

# download data on National Park sites ----
np_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/NPHT_Land_Salzburg/NPHT_Land_Salzburg.shp")

# download data on natural monuments ----
nd_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Naturdenkmaeler/Naturdenkmaeler.shp")

# download data on nature conservation areas ----
nsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Naturschutzgebiete/Naturschutzgebiete.shp")

# download data on plant protection areas ----
psg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Pflanzenschutzgebiete/Pflanzenschutzgebiete.shp")

# download data on wildlife reserves ----
wsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Wild_Europaschutzgebiete_VS_RL/Wild_Europaschutzgebiete_VS_RL.shp")
```

# Übersichtskarte 
```{r, eval=TRUE, results = FALSE}
#### -------------------------- Map of Salzburg --------------------------- ####
# add data on districts
bezirke <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/vgd/Salzburg_BEV_VGD_LAM.shp")

# change bezirke$GKZ to numeric to match joining row's format
bezirke$GKZ <- as.numeric(bezirke$GKZ)

# combine with spatial df on Gemeinde - join information on districts 
bezirk_list <- gem_grenz_raw %>%
  left_join(dplyr::select(as_tibble(bezirke), "PB", "GKZ"), 
            by = c("GEMNR" = "GKZ")) %>%
  distinct(GEMNR, .keep_all = TRUE) %>%
  # change names of Bezirke to traditional areas
  mutate(PB = case_when(          
    PB == "Salzburg-Umgebung" ~ "Flachgau",
    PB == "Hallein" ~ "Tennengau",
    PB == "Salzburg(Stadt)" ~ "Salzburg (Stadt)",
    PB == "Sankt Johann im Pongau" ~ "Pongau",
    PB == "Zell am See" ~ "Pinzgau",
    PB == "Tamsweg" ~ "Lungau")) %>%
  # for ordering in map legend
  mutate(PB = factor(PB, levels = c("Salzburg (Stadt)", "Flachgau", "Tennengau",
                                    "Pongau", "Pinzgau", "Lungau"))) 
                                  

# combine geometries of indiviual municpalities to get geometries for districts 
bezirk_grenz <- bezirk_list %>%
  group_by(PB) %>%
  summarise(geometry = sf::st_union(geometry)) %>%
  ungroup()
```

```{r, eval=TRUE, results = FALSE}
# Prepare data for plotting
# transform gem_grenz_raw to OSM CRS
gem_grenz_raw_3857 <- st_transform(gem_grenz_raw, "EPSG: 3857")

# extract map for inset map based on extent of gem_grenz_raw_3857
osm_sbg <- read_osm(gem_grenz_raw_3857, type = "esri-natgeo", ext=7)

# transform back to working CRS - EPSG:31258
osm_sbg <- st_transform(osm_sbg, "EPSG: 31258")

# create polygon to crop transformed inset map
bbox_inset <- bbox_to_poly(bbox = c(-59991.8259,-143180.5017,896875.9305,
                                    548802.6460), crs = 31258)

# crop osm_sbg to extent of bbox
osm_sbg <- st_crop(osm_sbg, bbox_inset)

# extract bbox from gem_grenz_raw
sbg_bbox <- st_bbox(gem_grenz_raw)

# use sbg_bbox to create a polygon to highlight area of interest in inset map
aoi_inset <- bbox_to_poly(sbg_bbox, crs = 31258)
```

```{r, eval = TRUE, fig.align='center'}
# Salzburg Map Plot Code

# create inset map
inset_karte<- tm_shape(osm_sbg) + 
  tm_rgb() +
  tm_shape(aoi_inset) +
  tm_borders(col="red", lwd = 3) +
  tm_layout(frame = F, bg.color = "transparent")

# create map of Salzburg with district and municipality boundaries
sbg_karte <-tm_shape(bezirk_grenz) + 
  tm_fill(col = "PB",
          # give each district a different fill shade
          palette = brewer.pal(6,"Set1"),
          legend.show = F) +
  # add borders of districts   
  tm_borders(lwd = 4,                 
             col = "black") +
  tm_shape(gem_grenz_raw) +
  # add shape and border of municipalities
  tm_polygons(alpha = 0,             
              lwd = 1,
              col = "black") +
  # add legend for district fill
  tm_add_legend(col = brewer.pal(6,"Set1"),  
                # custom ordering of districts  in legend
                labels = c("Salzburg (Stadt)", "Flachgau", "Tennengau", 
                           "Pongau", "Pinzgau", "Lungau" ), 
                title = "Bezirke") + 
  # add legend for district borders
  tm_add_legend(type = "line", 
                lwd = 4,
                col = "black",
                labels = "Bezirksgrenzen") +
  # add legend for municipality borders
  tm_add_legend(type = "line", 
                lwd = 1,
                col = "black",
                labels = "Gemeindegrenzen") + 
  tm_layout(legend.outside = TRUE, # place legend outside of map frame
            legend.text.size = 0.75, 
            legend.position = c("left","top"), # determine legend position
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02)) +
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESRI", type = 'text', legend.format = list(title.size = 0.1))
```

```{r, eval=TRUE}
# extract the municipalities belonging to Salzburg (Stadt) to a tibble 
salzburg_stadt_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Salzburg (Stadt)")

# extract the municipalities belonging to Flachgau to a tibble 
flachgau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Flachgau")

# extract the municipalities belonging to Tennengau to a tibble 
tennengau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Tennengau")

# extract the municipalities belonging to Pongau to a tibble 
pongau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Pongau")

# extract the municipalities belonging to Pinzgau to a tibble 
pinzgau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Pinzgau")

# extract the municipalities belonging to Lungaug to a tibble 
lungau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Lungau")

# create a knitr table with a list of districts and their municipalities
Salzburg_stadt <- kbl(select(salzburg_stadt_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Flachgau <- kbl(select(flachgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Tennengau <- kbl(select(tennengau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Pinzgau <- kbl(select(pinzgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Pongau <- kbl(select(pongau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Lungau <- kbl(select(lungau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")
```

```{r, eval = TRUE}
# print overview map of Salzburg
sbg_karte
print(inset_karte, vp = grid::viewport(0.83, 0.15, width = 0.3, height = 0.53))
```

Abbildung 2: Übersichtskarte von Salzburger Land

Das Land Sazlburg befindet sich im Westen von Österreich an der Grenze mit Deutschland und besteht aus 6 Bezirke, Sazlburg (Stadt), Flachgau, Tennengau, Pongau, Pinzgau und Lungau (siehe Abb. 2). Insgesamt hat Sazlburg 119 Gemeinden (siehe Tabelle 2).


Tabelle 2: Liste der Bezirke und deren Gemeinden
```{r, eval = TRUE, echo = FALSE}
# create a knitr table with a list of counties and their municipalities
kbl(select(salzburg_stadt_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
   kable_styling(full_width = F, position = "float_left")

kbl(select(tennengau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
   kable_styling(full_width = F, position = "float_left")


kbl(select(lungau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
  kable_styling(full_width = F, position = "float_left")

kbl(select(pongau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
  kable_styling(full_width = F, position = "right")

kbl(select(pinzgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
  kable_styling(full_width = F, position = "float_left")

kbl(select(flachgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
   kable_styling(full_width = F, position = "float_left")

kbl(select(flachgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top") %>%
   kable_styling(full_width = F, position = "left")
```


## Weitere Datenbereinigung
Die Daten wurden weiter bereinigt, um ihre Formatierung zu vereinheitlichen, was die Analyse der Daten erleichtert. Zudem wurden die Bevölkerungsdaten und Landtagswahldaten mit den gemeindebezogenen Geodaten verknüpft. Die Daten zu den Schutzgebieten wurden zusammengeführt und die Daten zur Flächenwidmung wurden auf ihre geometrische Gültigkeit geprüft und nach den Kriterien in Tabelle 1 aufgeteilt.   

```{r, eval = TRUE}
#### ------------------------ Further Data Cleaning ----------------------- ####
# clean the column names of all data frames and spatial data frames ----
# Get a list of all data frames in the global environment
df_list <- Filter(is.data.frame, mget(ls()))

# Loop through each data frame, apply clean_names(), and rename the data frame by removing _raw and pasting _clean
for (df_name in names(df_list)) {
  # Apply clean_names() to the data frame
  cleaned_df <- clean_names(get(df_name))
  
  # Change the name by appending "_clean" and removing "_raw" if present
  new_name <- gsub("_raw", "", paste0(df_name, "_clean"))
  
  # Assign the cleaned data frame with the new name to the global environment
  assign(new_name, clean_names(get(df_name)))
  
  rm(cleaned_df)
}
```

```{r, eval = TRUE}
# merge together population data with geometry data of muncipality ----

# aggregate Kastralgemeinde population to the Gemeinde (municipal) level 
gemeinden <- pop_clean %>% 
  filter(bundesland == "Salzburg") %>%
  select(-c(4,5)) %>%
  rename(c(gkz = 2, bevoelkerung = 4)) %>%
  group_by(gemeindename, gkz) %>%
  summarise(bevoelkerung = sum(bevoelkerung)) %>%
  # merge with gem_grenz_raw on basis of municipality name & code
  right_join(gem_grenz_clean, by = c("gkz" = "gemnr", "gemeindename" = "name")) %>%
  st_as_sf() # reasign as sf object

```

```{r, eval = TRUE}
# merge together municipality data with Landtagswahl data from 2023
# clean ltw_raw
ltw <- ltw_clean %>%
  # rename columns
  rename(gemnr = 1, name = 2, OeVP = 9, SPOe = 11, FPOe = 13, GRUENE = 15, 
         NEOS = 17, KPOe = 19, WIRS = 21, MFG = 23) %>% 
  # remove rows which don't contain municipality level data
  filter(!row_number() %in% c(1:17, 137:nrow(ltw_clean))) %>% 
  dplyr::select(-c(3:8, 10, 12, 14, 16, 18, 20, 22, 24:ncol(ltw_clean))) %>% 
  # remove columns that contain percentage data, turnout values and those that contain no data !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # remove all the in columns containing vote data
  mutate_at(c(3:10), ~str_replace_all(., "\\.", "")) %>% 
  # set columns containing vote data to numeric
  mutate_at(c(3:10), as.numeric) %>% 
  # set to double to allow for joining with gemeinden later
  mutate_at(1, as.double) %>% 
  # sum up the total number of votes for each municipality
  mutate(total_stimmen = rowSums(across(OeVP:MFG))) %>% 
  # calculate percentage of votes for each party in each municipality
  mutate(OeVP_prozent = OeVP/total_stimmen*100, 
         SPOe_prozent = SPOe/total_stimmen*100,
         FPOe_prozent = FPOe/total_stimmen*100, 
         GRUENE_prozent = GRUENE/total_stimmen*100,
         NEOS_prozent = NEOS/total_stimmen*100,
         KPOe_prozent = KPOe/total_stimmen*100, 
         WIRS_prozent = WIRS/total_stimmen*100,
         MFG_prozent = MFG/total_stimmen*100, .after = MFG) 

# join ltw with gemeinden
gemeinden_ltw <- gemeinden %>%
  # join gemeinden with ltw based on the Gemeinde Nummer
  left_join(ltw, by = c("gkz" = "gemnr")) %>% 
  # reorder columns so geometry is last and delete names as this data is duplicated
  dplyr::select(c(1:7), c(9:26), 8, -name) 
  
```

```{r, eval = TRUE}
# merge datasets on protected areas together ----

# merge cleaned datasets using bind_rows 
pa_all <- bind_rows(ffh_clean, geschuezte_lt_clean, geschuezte_ng_clean, 
                    lsg_clean, natura2000_clean, nd_clean, np_clean,
                    nsg_clean,psg_clean, ramsar_clean, spa_clean, wsg_clean)
```

```{r, eval = TRUE}
# extract water, roads, train tracks, solar parks, populated areas, ---- 
# enterprise areas, and residential areas from fl_wid_clean

# check validity of all geometries and correct if not
if ("geometry" %in% names(fl_wid_clean)) {
  
  # Check validity of geometries
  invalid_geoms <- st_is_valid(fl_wid_clean$geometry)
  
  # If there are invalid geometries, correct them using st_make_valid
  if (any(!invalid_geoms)) {
    # Identify and correct invalid geometries
    fl_wid_clean$geometry[!invalid_geoms] <- st_make_valid(fl_wid_clean$geometry[!invalid_geoms])
    
  }
  
}

# extract data for water, roads, train tracks, populated areas, 
# enterprise areas and solar farms and add a key for these categories

# populated areas
fl_wid_bewohnt <- fl_wid_clean %>%
  filter(typname == "BARW" | typname == "BAEW" | typname == "BAFW" | 
           typname == "BAKG" | typname == "BALK" | typname == "BADG" | 
           typname == "BABE" | typname == "BAGG" | typname == "BAIG" | 
           typname == "BAZG" | typname == "BAHV" | typname == "BAHC" | 
           typname == "BAHF" | typname == "BAHB" | typname == "BAHE" | 
           typname == "BABG") %>%
  mutate(kategorie = "bewohnt")

# residnetial areas
fl_wid_wohngebiete <- fl_wid_clean %>%
  filter(typname == "BARW" | typname == "BAEW" | typname == "BAFW" | 
           typname == "BAKG" | typname == "BALK" | typname == "BADG" | 
           typname == "BAZG" | typname == "BABG") %>%
  mutate(kategorie = "wohngebiet")

# enterprise/industrial areas
fl_wid_betriebe <- fl_wid_clean %>%
  filter(typname == "BADG" | typname == "BABE" | typname == "BAGG" | 
           typname == "BAIG" | typname == "BAHV" | typname == "BAHC" | 
           typname == "BAHF" | typname == "BAHB" | typname == "BAHE" | 
           typname == "BABG" | typname == "GLMG") %>%
  mutate(kategorie = "betrieb")

# water 
fl_wid_gewaesser <- fl_wid_clean %>%
  filter(typname == "GLGG") %>%
  mutate(kategorie = "gewaesser")

# train tracks
fl_wid_bahn <- fl_wid_clean %>%
  filter(typname == "VEEB") %>%
  mutate(kategorie = "bahn")

# roads
fl_wid_str <- fl_wid_clean %>%
  filter(typname == "VEGM" | typname == "VEBL" | typname == "VESO") %>%
  mutate(kategorie = "strasse")

# solar farms
fl_wid_solar <- fl_wid_clean %>%
  filter(typname == "GLSA") %>%
  mutate(kategorie = "solar")

# combine these into a new spatial dataframe with a key for each zoning category
fl_wid_kat_alle <- bind_rows(list(fl_wid_bahn, fl_wid_betriebe,
                                  fl_wid_bewohnt, fl_wid_gewaesser,
                                  fl_wid_str, fl_wid_wohngebiete,
                                  fl_wid_solar))
```

## Geometrische Operationen

In diesem Teil wurden geometrische Operationen ausschließlich mit Vectordaten durchgeführt. Mit diesen Daten wurden Puffer erstellt und Geometrien miteinander kombiniert und geclippt, um eine Polygongeometrie zu erstellen, die den Flächenkriterien entspricht, für die Faktoren, die hier behandelt wurden.

### Straßen

```{r}
#### -------------------------------- Roads ------------------------------- ####
# create buffer around roads
str_buffer <- fl_wid_kat_alle %>%
  # choose roads from df
  filter(kategorie == "strasse") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all road geometries into one polygon geometry
  st_union() %>% 
  # 500 m buffer around geometries
  st_buffer(500) %>% 
  # clip to size of state
  st_intersection(bundesland_clean) 
```

```{r, include=FALSE}
# write str_buffer to a shapefile
st_write(str_buffer, "daten_zwischenablage/str_buffer.shp", append = F)

# read in str_buffer
str_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/str_buffer.shp")
```

### Bewohnte Gebiete

```{r}
#### --------------------------- Populated Areas -------------------------- ####
# create buffer around populated areas

# combine all populated area geometries into one polygon geometry
bewohnt_buffer <- fl_wid_kat_alle %>%
  # choose populated areas from df
  filter(kategorie == "bewohnt") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all populated area geometries into one polygon geometry
  st_union() %>% 
  # 2500 m buffer around geometries
  st_buffer(2500)%>% 
  # clip to size of state
  st_intersection(bundesland_clean) 

```

```{r, include = FALSE}

# write bewohnt_buffer to a shapefile
st_write(bewohnt_buffer, "daten_zwischenablage/bewohnt_buffer.shp", append = F)

# read in bewohnt_buffer
bewohnt_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/bewohnt_buffer.shp")
```

### Wohngebiete

```{r}
#### -------------------------- Residential Areas ------------------------- ####
# create buffer around residential areas

# combine all residential area geometries into one polygon geometry
wohngebiete_buffer <- fl_wid_kat_alle %>%
  # choose residential areas from df
  filter(kategorie == "wohngebiet") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all residential area geometries into one polygon geometry
  st_union() %>% 
  # 500 m buffer around geometries
  st_buffer(500) %>% 
  # clip to size of state
  st_intersection(bundesland_clean) 
```

```{r, include = FALSE}
# write wohngebiete_buffer to a shapefile
st_write(wohngebiete_buffer, "daten_zwischenablage/wohngebiete_buffer.shp", 
         append = F)

# read in wohngebiete_buffer
wohngebiete_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/wohngebiete_buffer.shp")
```

### Betriebsgebiete

```{r}
#### --------------------- Enterprise/Indsutrial Areas -------------------- ####
# create buffer around enterprise/industrial areas

# combine all enterprise/industrial area geometries into one polygon geometry
betriebe_buffer <- fl_wid_kat_alle %>%
  # choose residential areas from df
  filter(kategorie == "betrieb") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all enterprise/industral area geometries into one polygon geometry
  st_union() %>% 
  # 3500 m buffer around geometries
  st_buffer(3500) %>% 
  # clip to size of stat
  st_intersection(bundesland_clean) e
```

```{r, include = FALSE}
# write betriebe_buffer to a shapefile
st_write(betriebe_buffer, "daten_zwischenablage/betriebe_buffer.shp", 
         append = F)

# read in betriebe_buffer
betriebe_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/betriebe_buffer.shp")
```

### Schutzgebiete

```{r, eval = TRUE}
#### --------------------------- Protected Areas -------------------------- #### 
# combine all polygons together on Protected Area Data

# check validity of all geometries and correct if not
if ("geometry" %in% names(pa_all)) {
  
  # Check validity of geometries
  invalid_geoms <- st_is_valid(pa_all$geometry)
  
  # If there are invalid geometries, correct them using st_make_valid
  if (any(!invalid_geoms)) {
    # Identify and correct invalid geometries
    pa_all$geometry[!invalid_geoms] <- st_make_valid(pa_all$geometry[!invalid_geoms])
    
  }
  
  # Join all protected area geometries into one multipolygon
  pa_comb <- st_union(pa_all$geometry)
  
} 
```

### Kombinieren von Vectorpuffern und Ausschneiden von ungeigneten Flächen

```{r}
#### ---------- Combine vector buffers and geometric conditions ----------- ####
# combine buffers outlining appropriate places - betriebe, bewohnt, str 
polygon_flaeche_geeignet_rein <- bind_rows(list(betriebe_buffer,
                                                bewohnt_buffer, 
                                                str_buffer)) %>%
  st_union()

# combine geometries of residential, populated , and enterprise/industrial areas, streets, train tracks, protected areas and water bodies
polygon_flaeche_ungeeignet_rein <- fl_wid_kat_alle %>%
  filter(kategorie == "wohngebiet" | kategorie == "bewohnt" | 
           kategorie == "betrieb" | kategorie == "gewaeser" | 
           kategorie == "bahn" | kategorie == "strasse") %>%
  select(geometry) %>%
  st_union() %>%
  st_union(wohngebiete_buffer) %>%
  st_union(pa_comb)

# clip the polygon of suitable areas to polygon_flaeche_ungeeignet_rein
polygon_flaeche_geeignet <- st_difference(polygon_flaeche_geeignet_rein, 
                                          polygon_flaeche_ungeeignet_rein)
```

```{r, include = FALSE}
st_write(polygon_flaeche_geeignet, "daten_zwischenablage/polygon_flaeche_geeignet.shp")

polygon_flaeche_geeignet <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/polygon_flaeche_geeignet.shp")
```

## Auswählen von tauglichen Landbedeckungstypen

```{r, include = FALSE, eval = TRUE}
# load in landcover data for Salzburg
lc_sbg <- rast("daten_zwischenablage/lc_sbg.tif")
```

Hier wurden die taugliche Landabdeckungstypen anhand von den Kriterien ausgewählt.

```{r}
#### ----------------------------- Land Cover ----------------------------- ####
# 10 - Tree Cover
# 20 - Shrublands # suitable
# 30 - Grassland # suitable
# 40 - Cropland # suitable 
# 50 - Built-up
# 60 - Bare/sparse vegetation # suitable
# 70 - Snow and ice
# 80 - Permanent water bodies
# 90 - Herbaceous wetland
# 100 - Moss and lichen

# mask to polygon_flaeche_geeignet 
lc_geeignet_fl <- mask(lc_sbg, polygon_flaeche_geeignet)

# set areas with suitable landcover to 1 and rest to na
lc_geeignet <- subst(lc_geeignet_fl, c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100), 
                     c(NA, 1, 1, 1, NA, 1, NA, NA, NA, NA), others=NA)
```

```{r, include=FALSE}
writeRaster(lc_geeignet, "daten_zwischenablage/lc_geeignet.tif", overwrite = T)

lc_geeignet <- rast("daten_zwischenablage/lc_geeignet.tif")
```

## Topographische Kriterien

In diesem Teil wurde das digitale Geländemodell für das Land Salzburg verwendet, um es mit der im letzten Teil erstellten Polygongeometrie zu schneiden. Dabei wurden die Flächen entfernt, die für Solaranlagen ungeeignet sind. Dann wurden Flächen über 1500 m herausgenommen. Außerdem wurden die Hangneigung und Hangausrichtung anhand des digitalen Geländemodells berechnet. 
```{r, include=FALSE, eval = TRUE}
# load in dgm
dgm <- rast("daten_zwischenablage/dgm.tif")
```

```{r}
#### ----------------------------- Topography ----------------------------- 

# mask the digital elevation model to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
dgm_geeignet_fl <- mask(dgm, polygon_flaeche_geeignet)

# set all cells above 1500 m in dgm_geeignet_fl to NA
dgm_geeignet <- terra::clamp(dgm_geeignet_fl, upper=1500, value=FALSE)
```

```{r, include = FALSE}
writeRaster(dgm_geeignet, "daten_zwischenablage/dgm_geeignet.tif")
```

```{r}
# calculate aspect from the digital elevation model
terra::terrain(dgm, v="aspect", neighbors=8, unit="degrees", filename="daten_zwischenablage/hangrichtung.tif", overwrite = T)

# calculate slope from digital elevation model
terra::terrain(dgm, v="slope", neighbors=8, unit="degrees", filename="daten_zwischenablage/hangneigung.tif", overwrite = T)

# read in data for asepct
hangausrichtung <- rast("daten_zwischenablage/hangausrichtung.tif")

# read in data for slope
hangneigung <- rast("daten_zwischenablage/hangneigung.tif")
```

Als nächstes wurden die Flächen identifiziert, die auch den Kriterien für Hangneigung und Hangausrichtung entsprechen. 
```{r}
# criteria: slope less than 15 degrees
# mask the slope raster to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
hangneigung_geeignet_fl <- terra::mask(hangneigung, polygon_flaeche_geeignet)

# define values for matrix to set areas with suitable gradient (0-15 degrees) to 1 and rest to na
hangneigung_zahl <- c(0, 15, 1)

# create matrix for re-classification
hangneigung_matr <- matrix(hangneigung_zahl, ncol=3, byrow=TRUE)

# reclassify areas of suitable gradient and set other areas to NA
hangneigung_geeignet_alle <- classify(hangneigung_geeignet_fl,
                                      hangneigung_matr, others=NA)

# define values for matrix to set areas with a gradient lower than 3.5 to 1 and rest to na (to be used in conjunction with aspect data)
hangneigung_zahl_3_5 <- c(0, 3.5, 1)

# create matrix for re-classification
hangneigung_matr_3_5 <- matrix(hangneigung_zahl_3_5, ncol=3, byrow=TRUE)

# reclassify areas meeting gradient criteria and set other areas to NA
hangneigung_geeignet_unter_3_5 <- classify(hangneigung_geeignet_fl,
                                           hangneigung_matr_3_5, others=NA)

# clip hangneigung_geeignet_alle with dgm_geeignet
hn_dgm_geeignet <- terra::mask(hangneigung_geeignet_alle, dgm_geeignet)
```

```{r}
# overall criteria: aspect between 110 - 200 (unless slope is less than 3.5 degrees, then aspect is not taken into account)

# mask the aspect raster to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
hangausrichtung_geeignet_fl <- terra::mask(hangausrichtung,
                                           polygon_flaeche_geeignet)

# define values for matrix to set areas with an aspect from 110-200 to 1 and rest to na
hangausrichtung_zahl <- c(110, 200, 1)

# create matrix for reclassification
hangausrichtung_matr <- matrix(hangausrichtung_zahl, ncol=3, byrow=TRUE)

# reclassify areas meeting aspect criteria and set other areas to NA
hangausrichtung_geeignet <- classify(hangausrichtung_geeignet_fl,
                                     hangausrichtung_matr, others=NA)

# clip with hn_dgm_geeignet
hn_dgm_ha_geeignet <- terra::mask(hn_dgm_geeignet,
                                  hangausrichtung_geeignet)
```

```{r, include = FALSE}
writeRaster(hn_dgm_ha_geeignet, "daten_zwischenablage/hn_dgm_ha_geeignet.tif")
```

```{r}
# add in those areas under 3.5 degrees of gradient
topographie_geeignet <- terra::merge(hn_dgm_ha_geeignet,
                                     hangneigung_geeignet_unter_3_5)
```

```{r, include = FALSE}
writeRaster(topographie_geeignet, "daten_zwischenablage/topographie_geeignet.tif")
topographie_geeignet <- rast("daten_zwischenablage/topographie_geeignet.tif")
```

## Einbeziehung der Solareinstrahlung
Die Daten zur Sonneneinstrahlung wurden an diesem Schritt einbezogen und das Kriterium einer Mindestsonneneinstrahlung von 1100 kWh/m^2^/Jahr wurde für die bisherigen geeigneten Flächen mitberücksichtigt. 
```{r, include=FALSE}
# load in saved resampled raster
solar_resample <- rast("daten_zwischenablage/solar_resample.tif")
```

```{r}
#### --------------------------- Solar Radiation -------------------------- ####
# resample solar_raw to a lower resolution based on dgm (otherwise R does not compute)
# also to allow for more contiguous areas - with 1x1 resolution - there would likely be very fragemetned areas
solar_resample <- resample(solar_raw, dgm)

# set values of areas which do satisfy the 1100 kw/yr requirement to NA
solar_geeignet <- terra::clamp(solar_resample, lower=1100, value=FALSE)
```

```{r, include = FALSE}
# write out raster
writeRaster(solar_geeignet, "daten_zwischenablage/solar_geeignet.tif", overwrite = T)
```

```{r}
#### ------------ Combine solar_geeignet & topographie_geeignet ----------- ####
# mask suitable topographical areas with areas with sufficient solar radiation
# done as these rasters are on the smae grid and at the same resolution
top_solar_geeignet <- terra::mask(topographie_geeignet, solar_geeignet)
```

```{r, include = FALSE}
# write out raster
writeRaster(top_solar_geeignet,"daten_zwischenablage/top_solar_geeignet.tif")
```

## Umwandeln zu SF zum Abbilden
Hier wurden die Rasterdaten zu Vectordaten umwgewandelt und die Landabdeckungsdaten miteinbezogen, um die endgultige Flächenkulisse für geeignete Solaranlagenflächen zu erstellen. 
```{r}
#### --------------------------- Convert to sf ---------------------------- ####
# topography-solar combined raster

# force raster to polygon
top_solar_geeignet_vec <- as.polygons(top_solar_geeignet)

# change to sf object and select only geometry
top_solar_geeignet_vec <- st_as_sf(top_solar_geeignet_vec) %>%
  select(geometry)

# lc raster

# force raster to polygon
lc_geeignet_vec <- as.polygons(lc_geeignet)

# change to sf object and select only geometry
lc_geeignet_vec <- st_as_sf(lc_geeignet_vec) %>%
  select(geometry)

# find intersection between solar, topography and lc areas
flaeche_geeignet <- st_intersection(top_solar_geeignet_vec, lc_geeignet_vec)
```

```{r, include = FALSE}
# write out shp
st_write(flaeche_geeignet, "daten_zwischenablage/flaeche_geeignet.shp")
```

```{r, include = FALSE, eval=TRUE}
# read in flaeche_geeignet
flaeche_geeignet <- st_read("daten_zwischenablage/flaeche_geeignet.shp")
```

## Solaranlage in Salzburg - Aktuell und Potenzial

```{r, eval=TRUE}
# calculate area suitable for potential solar farms
fg_flaeche <- set_units(st_area(flaeche_geeignet), "km^2")
fg_flaeche
```

```{r, eval=TRUE}
# calculate percentage cover of Salzburg from current solar farms 
(st_area(flaeche_geeignet)/st_area(bundesland))*100
```

```{r, eval=TRUE}
# calculate area of current solar farms
as_flaeche <- set_units(st_area(st_union(fl_wid_solar)), "km^2")
as_flaeche
```

```{r, eval=TRUE}
# calculate percentage cover of Salzburg from current solar farms 
(st_area(st_union(fl_wid_solar))/st_area(bundesland))*100
```

```{r, eval=TRUE}
# calculate the percentage difference between current and potential solar farms
(st_area(flaeche_geeignet)/st_area(st_union(fl_wid_solar)))*100
```



```{r, eval=TRUE, fig.align='center'}
#### -------- Map of Potential Solar Areas and Current Solar Areas -------- ####
# plot map
tm_shape(flaeche_geeignet, bbox = st_bbox(gemeinden_ltw)) + # use gemeinden_ltw bbox as flaeche_geeignet bounding box gets cut off
  # add yellow polygons for areas suitable for solar farms
  tm_polygons(col= "yellow", 
              border.col = "yellow") +
  tm_shape(fl_wid_solar) + 
  # add red polygons for areas suitable for solar farms
  tm_polygons(col= "red", 
              border.col = "red") +
  # add borders of municipalities
  tm_shape(gemeinden_ltw) +
  tm_borders(col="black", 
             lwd=2) + 
  # add legend 
  tm_add_legend(type = c("fill"),
                labels = c("Geeingte Solarfläche", "Bestehende Anlagen"),
                col = c( "yellow", "red"),
                border.lwd = 0) +
  # add title and format legend 
  tm_layout(main.title = "Geeignete Solarfläche und Bestehende Solaranlagen", 
            main.title.fontface = 2, fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", type = 'text', legend.format = list(title.size = 0.1))
```
Abbildung 3: Karte der potenziellen Solaranlageflächen und der aktuellen Solaranlagen im Land Salzburg

Aktuell gibt es sehr wenig Solaranlagen im Land Sazlburg (siehe Abb. 3). Diese Flächen beträgen nur 0.04978409 km^2^, was 0.0006952127 % der Fläche des Landes sind. Die derzeitigen Solaranlagen befinden sich im Flachau im Süden und Leogang im Westen vom Bundesland. Im Vergleich dazu gibt es potenzielle Fläche für Solaranlagen in allen Gemeinden außer Krimml im Südwesten des Bundeslandes (siehe Abb. 3). Die geeigneten Flächen machen 137.5035 km^2^ aus, was 1.920175 % der Landesfläche darstellen. Das würde einen prozentualen Ansteig in Solarflächen von 276199.7 % zeigen, wenn diese potenziellen Solaranlagen verwirklicht werden würden.


## Hotspot Analyse

### Datenvorbereitung

Eine Hotspot Anlayse wurde durchgeführt. Um die Daten darauf vorzubereiten, wurden die geeignete Solaranlangenfläche, Grünlandfläche, Fläche der bewohnten Gebiete, und Flächen von Berggebieten für jede Gemeinde berechnet und nach Gemeindegröße standardisiert.  
```{r, eval=TRUE}
#### ----------- Cluster Analysis and Spatial Autoceorrelation ------------ ####

#### calculate the amount of suitable solar farm area in each municipality ----

# find intersection of suitable solar farm areas per municipality
gemeinden_solar <- st_intersection(flaeche_geeignet, gemeinden_ltw)

# find the area of suitable solar farm areas per municipality
gemeinden_solar$pot_solar_flaeche <- st_area(gemeinden_solar)

# convert to tibble and select just the area of the suitable solar farm areas and gkz for joining 
gemeinden_solar_df <- as_tibble(gemeinden_solar) %>%
  select(c(gkz, pot_solar_flaeche))

# join with other data on municipalities
gemeinden_voll <- gemeinden_ltw %>%
  left_join(gemeinden_solar_df)
```

```{r}
#### calculate amount of grassland per municipality ----

# set the value of grassland to 1 and everything else to NA
lc_gland <- subst(lc_sbg,c(0, 30), c(NA, 1), others=NA)

# convert sf multipolygon to terra vector
gemeinden_terra <- vect(gemeinden_voll)

# extract raster values for each polygon
gland_pixels <- terra::extract(lc_gland, gemeinden_terra, fun = sum, 
                               na.rm = TRUE)

# add unique identifier from gemeinden_solar to extracted values
gland_pixels$gkz <- gemeinden_voll$gkz

# calculate pixel area
pixel_flaeche <- prod(res(lc_gland))

# convert pixel counts to area
gland_pixels$gruenland_flaeche <- gland_pixels$ESA_WorldCover_10m_2021_v200_N45E012_Map * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
gland_pixels$gruenland_flaeche <- set_units(gland_pixels$gruenland_flaeche,
                                            "m^2") 

# combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(gland_pixels[, c("gkz", "gruenland_flaeche")], by = "gkz")
```

```{r, include=FALSE, eval=TRUE}
#### calculate amount of grassland per municipality ----

gland_pixels <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/gland_pixels.csv")

# Add unique identifier from gemeinden_solar to extracted values
gland_pixels$gkz <- gemeinden_voll$gkz

# Calculate pixel area
pixel_flaeche <- prod(res(lc_sbg))

# Convert pixel counts to area
gland_pixels$gruenland_flaeche <- gland_pixels$ESA_WorldCover_10m_2021_v200_N45E012_Map * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
gland_pixels$gruenland_flaeche <- set_units(gland_pixels$gruenland_flaeche,
                                          "m^2") 

# Combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(gland_pixels[, c("gkz", "gruenland_flaeche")], by = "gkz")
```

```{r, eval=TRUE}
#### Calculate the amount of populated area per municipality ----

# initiate vector to store data on populated area per municipality
bewohnte_flaeche_pro_gemeinde <- c()

# calculate the populated area within each municipality
for (i in 1:nrow(gemeinden_voll)) { 
  
  bewohnte_flaeche_pro_gemeinde[i] <- st_intersection(fl_wid_bewohnt, gemeinden_voll$geometry[i]) %>%
  st_union() %>%
  st_area()
}

# add this to gemeinden_voll
gemeinden_voll <- gemeinden_voll %>%
  add_column(bewohnte_flaeche = bewohnte_flaeche_pro_gemeinde)

# add units of metres squared
gemeinden_voll$bewohnte_flaeche <-  set_units(gemeinden_voll$bewohnte_flaeche,"m^2")
```

```{r}
#### Calculate amount of mountain area per municipality ----

# define values for matrix to set areas above 1500 m to 1 and rest to na
dgm_1500_zahl <- c(1500, Inf, 1)

# create matrix for re-classification
dgm_1500_matr <- matrix(dgm_1500_zahl, ncol=3, byrow=TRUE)

# reclassify areas under 1500 m to NA
dgm_1500 <- classify(dgm, dgm_1500_matr, others=NA)

# extract raster values for each polygon
dgm_pixels <- terra::extract(dgm_1500, gemeinden_terra, fun = sum, na.rm = TRUE)

# add unique identifier from gemeinden_voll to extracted values
dgm_pixels$gkz <- gemeinden_voll$gkz

# calculate pixel area
pixel_flaeche <- prod(res(dgm_1500))

# convert pixel counts to area
dgm_pixels$berg_flaeche <- dgm_pixels$dgm5m * pixel_flaeche

# add units to gland_pixel$berg_flaeche
dgm_pixels$berg_flaeche <- set_units(dgm_pixels$berg_flaeche,
                                    "m^2") 
# replace na values with 0
dgm_pixels$berg_flaeche[is.na(dgm_pixels$berg_flaeche)] <- 0

# combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(dgm_pixels[, c("gkz", "berg_flaeche")], by = "gkz")
```

```{r, include=FALSE, eval=TRUE}
#### Calculate amount of mountain area per municipality ----
dgm_pixels <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/dgm_pixels.csv")

# Add unique identifier from gemeinden_solar to extracted values
dgm_pixels$gkz <- gemeinden_voll$gkz

# Calculate pixel area
pixel_flaeche <- prod(res(dgm))

# Convert pixel counts to area
dgm_pixels$berg_flaeche <- dgm_pixels$dgm5m * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
dgm_pixels$berg_flaeche <- set_units(dgm_pixels$berg_flaeche,
                                    "m^2") 
# replace na values with 0
dgm_pixels$berg_flaeche[is.na(dgm_pixels$berg_flaeche)] <- 0

# Combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(dgm_pixels[, c("gkz", "berg_flaeche")], by = "gkz")
```

```{r, eval=TRUE}
#### Calculate proportions of appropriate solar farm areas, grassland and populated areas per municipality in terms of their total area ----

gemeinden_data <- gemeinden_voll %>%
  # calculate area of each municipality and mutate to tibble
  mutate(flaeche = st_area(geometry)) %>%
  # calculate the percentage of potential solar farm, grassland, populated and mountain areas per municipality and mutate it to tibble
  mutate(solar_anteil = 
           as.numeric(pot_solar_flaeche)/as.numeric(flaeche) * 100,
         gruenland_anteil =
           as.numeric(gruenland_flaeche)/as.numeric(flaeche) * 100,
         bewohnt_anteil = as.numeric(bewohnte_flaeche)/as.numeric(flaeche) * 100,
         berg_anteil = as.numeric(berg_flaeche)/as.numeric(flaeche)) %>%
  # remove the shape_area and shape_len columns
  dplyr::select(-c(shape_area, shape_len)) %>%
  # rearrange order of columns 
  relocate(geometry, .after = last_col()) %>%
  relocate(solar_anteil, .after = pot_solar_flaeche) %>%
  relocate(gruenland_anteil, .after = gruenland_flaeche) %>%
  relocate(bewohnt_anteil, .after = bewohnte_flaeche) %>%
  relocate(berg_anteil, .after = berg_flaeche) %>%
  # calculate the population density in km2 and mutate to tibble
  mutate(einwohnerzahl_pro_qkm = bevoelkerung/as.numeric(set_units(flaeche, "km^2")), .after = bevoelkerung) %>%
  # transform back to sf object
  st_as_sf()
```

### Interaktive Karte
```{r, eval = TRUE}
#### ---------------------------- Leaflet Map ----------------------------- ####
# transform layers to EPSG: 4326 for plotting
flaeche_geeignet_4326 <- st_transform(flaeche_geeignet, "EPSG: 4326")
fl_wid_solar_4326 <- st_transform(fl_wid_solar, "EPSG: 4326")
fl_wid_bewohnt_4326 <- st_transform(fl_wid_bewohnt, "EPSG: 4326")
pa_comb_4326 <- st_transform(pa_comb, "EPSG: 4326")
gemeinden_data_4326 <- st_transform(gemeinden_data, "EPSG: 4326")
bezirk_grenz_4326 <- st_transform(bezirk_grenz, "EPSG: 4326")
```
```{r, eval = TRUE}
# create basemap
basemap <- leaflet() %>% 
  setView(lng = 13, lat = 47.5, zoom = 8.4) %>%
  # add different provider tiles
  addProviderTiles(
    "OpenStreetMap",
    # give the layer a name
    group = "OpenStreetMap"
  ) %>%
  addProviderTiles(
    "CartoDB.Positron",
    group = "CartoDB.Positron"
  ) %>%
  addProviderTiles(
    "Esri.WorldTopoMap",
    group = "Esri.WorldTopoMap"
  ) %>%
  addProviderTiles(
    "Esri.WorldImagery",
    group = "Esri.WorldImagery"
  ) %>%
  addProviderTiles(
    "Esri.WorldTerrain",
    group = "Esri.WorldTerrain"
  ) %>%
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap","CartoDB.Positron", "Esri.WorldTopoMap",
      "Esri.WorldImagery", "Esri.WorldTerrain"
    ),
    # position it on the topleft
    position = "topleft"
  )

# plot map 
basemap %>%
  addPolygons(
    data = bezirk_grenz_4326,
    stroke = TRUE,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 2,
    fillColor = "whitesmoke",
    # set the fill opacity
    fillOpacity = 0.3,
    group = "Bezirke",
    popup = paste("<b>Bezirk</b> ", "<br>", bezirk_grenz_4326$PB),
    highlightOptions = highlightOptions(color = "black", weight = 4, bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = fl_wid_solar_4326,
    # set the color of the polygon
    color = "red",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    # set the fill opacity
    fillColor = "red",
    fillOpacity = 0.6,
    group = "Bestehende Solaranlagen"
  ) %>%
  
  addPolygons(
    data = flaeche_geeignet_4326,
    # set the color of the polygon
    color = "yellow",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "yellow",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Geeignete Solarfläche"
  ) %>%
  
  addPolygons(
    data = pa_comb_4326,
    # set the color of the polygon
    color = "green",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "green",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Schutzgebiete"
  ) %>%
  addPolygons(
    data = fl_wid_bewohnt_4326,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "black",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Bewohnte Gebiete"
  ) %>%
  addPolygons(
    data = gemeinden_data_4326,
    stroke = TRUE,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "grey",
    # set the fill opacity
    fillOpacity = 0,
    group = "Gemeinden",
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  gemeinden_data_4326$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Bevölkerung</br> ",
                  "<br><b>Einwohnerzahl:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  gemeinden_data_4326$bevoelkerung,
                  "<br><b>Bevölkerungsdichte:</b> ", 
                  format(round(gemeinden_data_4326$einwohnerzahl_pro_qkm, 3), 
                         nsmall = 3), "Einwohner/km","<br>", 
                  "<br><b>Solar</br> ",
                  "<br><b>Geeignete Solarfläche (Absolut):</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(set_units(gemeinden_data_4326$pot_solar_flaeche,
                                         km^2), 3), nsmall = 3),
                  "<br><b>Geeignete Solarfläche (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$solar_anteil, 3), 
                         nsmall = 3), "%", "<br>", "<br><b>Landnutzung</br> ",
                  "<br><b>Grünland (Anteil):</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(gemeinden_data_4326$gruenland_anteil, 3), nsmall = 3),
                  "%","<br><b>Bewohnte Gebiete (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$bewohnt_anteil, 3), nsmall = 3), 
                  "%", "<br><b>Bergfläche (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$berg_anteil, 3), nsmall = 3), 
                  "%"),
    highlightOptions = highlightOptions(color = "black", weight = 4, bringToFront = TRUE)
  ) %>%
  # add a layers control
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap","CartoDB.Positron", "Esri.WorldTopoMap",
      "Esri.WorldImagery", "Esri.WorldTerrain"
    ),
    overlayGroups = c("Bezirke", "Gemeinden", "Bestehende Solaranlagen", 
                      "Geeignete Solarfläche", "Schutzgebiete", 
                      "Bewohnte Gebiete"),
    # position it on the top left
    position = "topleft"
  )

```
Abbildung 4: Interaktive Leaflet-Karte. Die Verwaltungsgrenzen, bestehende Solaranlagen, geeignete Solarfläche, Schutzgebiete und bewohnte Gebiete werden auf der Karte gezeigt. Zusätzlich enthalten die Pop-Ups Informationen zu der Bevölkerung, Solarfläche und Landnutzung jeder Gemeinde.

Mit der interaktiven Karte kann es gesehen werden, wie die potentiziellen Solarflächen in Hinsicht auf die Gemeinden, Schutzgebiete, bewohnte Gebiete und bestehende Solaranlagen verteilt werden (siehe Abb. 4)

### Durchführgun der Hotspot Analyse und Räumliche Autocorrelation

Die Zentren jeder Gemeinde werden bestimmt und dann wird ein fester maximaler Abstand von 20.000 m zwischen den Zentren jeder Gemeinde verwendet, um Nachbarn zu definieren.  (talk about what method for hotspot analysis and spatial autcorrelation)
```{r, eval=TRUE, fig.align='center'}
#### Spatial autocorrelation ----

#### Calculate spatial autocorrelation of potential solar farm areas, grassland, populated areas and mountainous areas

#create centroids and join neighbours within 20,000 m so that every municipality has a neighbour
gemeinde_nachbarn <- dnearneigh(st_geometry(st_centroid(gemeinden_data)), 0, 20000)

# create a neighbours list
gemeinde_nachbarn_gewichte<- gemeinde_nachbarn %>% 
  nb2listw(., style = "B")

# create sf df with centroids of each municipality
gemeinde_zentroide <- gemeinden_data %>% 
  st_centroid()

# plot neighbours using centroids
plot(gemeinde_nachbarn_gewichte, st_geometry(gemeinde_zentroide), col = "green", pch = 20, cex = 0.5)
```
Abbildung 5: Nachbarn jeweilger Gemeinde

Nachstehend wurde ein Getis-Ord-Gi * -Test durchgeführt, der die Gi * -Statistik liefert. Diese Statistik identifiziert Hot Spots und Cold Spots für jeden analysierten Merkmal, indem die Nachbarn in einem bestimmten Umkreis (20.000 m) betrachtet werden (siehe Abb. 5), um festzustellen, wo sich entweder hohe oder niedrige Werte räumlich konzentrieren, und um statistisch signifikante Hot Spots als Bereiche mit hohen Werten zu identifizieren, in denen andere Bereiche in der Nachbarschaft ebenfalls hohe Werte aufweisen (und umgekehrt für Cold Spots). Der z-Score (auch Gi*-Statistik genannt) ist ein standardisierter Wert, der angibt, ob sich hohe oder niedrige Werte konzentrieren. 

```{r, eval=TRUE}
#create GI-Statistics for absolute values on potential solar farm areas
GI_solar_absolut <- gemeinden_data %>%
  pull(pot_solar_flaeche) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on potential solar farm areas
GI_solar_relativ <- gemeinden_data %>%
  pull(solar_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on grassland areas
GI_gland_relativ <- gemeinden_data %>%
  pull(gruenland_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on populated areas
GI_bewohnt_relativ <- gemeinden_data %>%
  pull(bewohnt_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on mountain areas
GI_berg_relativ <- gemeinden_data %>%
  pull(berg_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()
```

```{r, eval=TRUE}
# join the local Gi* statistics to the names, gkz and geometry column of the gemeinden_data spatial dataframe
gemeinden_GI <- gemeinden_data %>% 
  select(c(1,2,5, 23:31)) %>%
  add_column(gi_solar_absolut = GI_solar_absolut,
         gi_solar_relativ = GI_solar_relativ,
         gi_gland_relativ = GI_gland_relativ,
         gi_bewohnt_relativ = GI_bewohnt_relativ,
         gi_berg_relativ = GI_berg_relativ) %>%
  relocate(geometry, .after = last_col()) %>% 
  st_as_sf() 
 
# Convert units to kn^2 of potential solar farm areas
gemeinden_GI$pot_solar_flaeche <- set_units(gemeinden_GI$pot_solar_flaeche, "km^2") 
```

```{r, eval=TRUE}
#### Chloropeth Maps and GI Maps

# create colour palettes for chloropeth maps
solar_palette <- rev(heat.colors(8))
gland_palette <- brewer.pal(8, "Greens")
bewohnt_palette <- brewer.pal(8, "Blues")
berg_palette <- brewer.pal(8, "Greys")

# create a color ramp function
farben_hotspot <- colorRampPalette(c("blue", "white","red"))

# create a colour palette for autocorrelation maps
GIFarben <- farben_hotspot(13)
```

```{r, eval=TRUE, fig.align='center'}
# solar absolute - chloropeth
sol_abs_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the solar_palette to reflect the amount of suitable solar areas in each municipality
  tm_fill("pot_solar_flaeche", 
          title = "Fläche\n(Quadratlkilometer)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = solar_palette, border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (absolut)\n ", 
            main.title.fontface = 2, 
            fontfamily = "Arial", 
            main.title.size =1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich",
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Solar absolute - GI Map
sol_abs_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of suitable solar areas (absolute) per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_solar_absolut", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-3, -2, -1, 0, 1, 2, 3, 4, 5, 6),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
    # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (absolut)\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size =1.2, 
            legend.outside = TRUE, 
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  tm_shape(gemeinden_GI) + 
  tm_borders(col="black", lwd=2) +
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

sol_abs_komb_karte <- tmap_arrange(sol_abs_karte, sol_abs_gi_karte)

sol_abs_komb_karte

```
Abbildung 6: Chloropeth-Karten mit der räumlichen Verteilung der absoluten Fläche der geeigneten Solarfläche über die Gemeinden (links) und einer Hotspotanalyse, die mögliche Clusterbildungen dieses Merkmales zeigt (rechts).

Betrachtet man die absolute Fläche der für Solaranlagen geeigneten Orte, so konzentrieren sich die Gemeinden mit der größten Fläche auf die nördlichen Gebiete des Bundeslandes (siehe Abb. 6). Im Südwesten gibt es ebenfalls Gemeinden mit einer mäßigen bis geringen Fläche, die für Solaranlagen geeignet sind. Ansonsten besteht der Rest des Bundeslandes aus Gemeinden, die wenig geeignete Flächen für Solarparks aufweisen. 
```{r, eval=TRUE, fig.align='center'}
# Solar relative - chloropeth map
sol_rel_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the solar_palette to reflect the percentage of land that is suitable for solar farms in each municipality
  tm_fill("solar_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "jenks",
          textNA = "No data",
          colorNA = "white", 
          palette = solar_palette, 
          border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (relativ)\n ", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Solar relative - GI Map
sol_rel_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of suitable solar areas per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_solar_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (relativ)\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 0.75, 
            legend.title.fontface = 2,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

sol_rel_comb_karte <- tmap_arrange(sol_rel_karte, sol_rel_gi_karte)

sol_rel_comb_karte
```
Abbildung 7: Chloropeth-Karten mit der räumlichen Verteilung der relativen Größe der geeigneten Solarfläche pro Gemeinde über die Gemeinden (links) und einer Hotspotanalyse, die mögliche Clusterbildungen dieses Merkmales zeigt (rechts).

Die Ergebnisse sind bei Betrachtung der Fläche pro Gemeinde etwas unterschiedlich. Im Norden des Bundesstaates scheint die Konzentration von Gemeinden mit einem höheren Anteil an für Solaranlagen geeigneten Flächen noch stärker ausgeprägt zu sein (siehe Abb. 7). Im Rest des Bundeslandes sind die Werte relativ niedrig und die Cold Spots konzentrieren sich auf den zentralen südlichen Teil des Bundeslandes.
```{r, eval=TRUE, fig.align='center'}
# Grassland relative - chloropeth map
gland_karte <-tm_shape(gemeinden_GI) +
  # fill the geometries using the gland_palette to reflect the percentage of grassland cover in each municipality
  tm_fill("gruenland_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = gland_palette, border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title 
  tm_layout(main.title = "Grünland (relativ)", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Grassland - GI map
gland_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of grassland cover per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_gland_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Grünland - Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

gland_komb_karte <- tmap_arrange(gland_karte, gland_gi_karte)

gland_komb_karte
```
Abbildung 8: Chloropeth-Karten mit der räumlichen Verteilung der Grünlandflächen über die Gemeinden (links) und einer Hotspotanalyse, die mögliche Clusterbildungen dieses Merkmales zeigt (rechts).

Die Gemeinden mit dem höchsten Anteil an Grünland befinden sich hauptsächlich im Norden des Bundesstaates und sind dort konzentriert (siehe Abb. 8). In den südlichen Teilen des Bundeslandes gibt es auch eine Reihe von Gemeinden mit einem Grünlandanteil von etwa 40 bis 60 %, die nach den Gemeinden im Norden einen zweiten Hotspot von Grünlandflächen im Land Sazlburg darstellen.  
```{r, eval=TRUE, fig.align='center'}
# Populated relative - chloropeth map
bewohnt_karte <-tm_shape(gemeinden_GI) +
  # fill the geometries using the bewohnt_palette to reflect the percentage of populated land in each municipality
  tm_fill("bewohnt_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "jenks",
          textNA = "No data",
          colorNA = "white", 
          palette = bewohnt_palette, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Bewohnte Gebiete (relativ)\n ", 
            main.title.fontface = 2, 
            fontfamily = "Arial", 
            main.title.size = 1.2, 
            legend.outside = TRUE, 
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size= 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Populated areas - GI map
bewohnt_gi_karte <- tm_shape(gemeinden_GI) +
    # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of populated area per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_bewohnt_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed",
          breaks = c(-2, -1, 0, 1, 2, 3, 4, 5, 6),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders 
  tm_borders(col="black", 
             lwd=2) +
  # add legend and title
  tm_layout(main.title = "Bewohnte Gebiete\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

bewohnt_komb_karte <- tmap_arrange(bewohnt_karte, bewohnt_gi_karte)

bewohnt_komb_karte
```
Abbildung 9: Chloropeth-Karten mit der räumlichen Verteilung der Fläche von bewohnten Gebieten über die Gemeinden (links) und einer Hotspotanalyse, die mögliche Clusterbildungen dieses Merkmales zeigt (rechts).

Die Gemeinden mit dem höchsten Anteil an bewohnten Gebieten befinden sich laut den Karten fast alle im Norden des Bundeslandes (siehe Abb. 9). 
```{r, eval=TRUE, fig.align='center'}
# Mountains relative - chloropeth map
berge_karte <-tm_shape(gemeinden_GI) +
    # fill the geometries using the berg_palette to reflect the percentage of mountainous area (> 1500 m) in each municipality
  tm_fill("berg_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = berg_palette, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Berge (relativ)", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Mountainous areas - GI map
berge_gi_karte <-tm_shape(gemeinden_GI) +
    # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of mountainous area (> 1500 m) per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_berg_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) +
  # add legend and title
  tm_layout(main.title = "Berge - Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

berge_komb_karte <- tmap_arrange(berge_karte, berge_gi_karte)

berge_komb_karte
```
Abbildung 10: Chloropeth-Karten mit der räumlichen Verteilung der Berggebieten über die Gemeinden (links) und einer Hotspotanalyse, die mögliche Clusterbildungen dieses Merkmales zeigt (rechts).

Die Berggebiete konzentrieren sich auf die südlichen Randgebiete des Landes (siehe Abb. 10). Im Süden befinden sich die Gemeinden mit dem höchsten Anteil an Berggebieten. Je weiter man nach Norden kommt, desto geringer ist im Allgemeinen der Anteil an Berggebieten pro Gemeinde. 

### Cluster Analyse

Eine k-Means Clusteranalyse mit den Merkmalen Bevölkerungsdichte, Anteil der geeigneten Fläche für Solaranlagen, Gründlandanteil, Anteil bewohnter Fläche und Anteil der Berggebiete von jeder Gemeinde erfolgte.   
```{r, eval=TRUE}
#### Cluster analysis ----

# select municipality name, gkz, population density and relative coverage columns
gemeinden_clus <- gemeinden_data %>% 
  as_tibble() %>%
  dplyr::select(c(1:2, 4, 25, 27, 29, 31, 33)) %>%
  # scale clustering columns
  mutate_at(c(3:7), ~(scale(.) %>% as.vector)) %>% 
  # rename rows as municipality names
  column_to_rownames("gemeindename") 
```

Die Ellebogen-Methode wurde angewandt, um die optimale Clusterzahl zu bestimmen. Diese Methode identifiziert den Punkt, ab dem die Verkeleinerung der Gesamtvariation kleiner wird.
```{r, eval=TRUE}
# use elbow method to determine number of clusters
fviz_nbclust(gemeinden_clus[,2:6], kmeans, method = "wss")
```
Abbildung 11: Die Ellebogen-Methode zeigt, dass die optimale Clusterzahl drei ist
```{r, eval=TRUE}
# create clusters based on elbow method - 3 clusters
clusters <- kmeans(gemeinden_clus[,2:6], centers=3, nstart=25)

# view cluster features
clusters
```

```{r, eval=TRUE}
# visualise clusters graphically - maybe don't need when have map?
fviz_cluster(clusters, data = gemeinden_clus[,2:6])
```
Abbildung 12: Gruppierungen von den Gemeinden in Clustern
```{r, eval=TRUE, fig.align='center'}
# Mapping clusters

# Add clusters to gemeinden_clus df
gemeinden_clus <- gemeinden_clus %>%
  mutate(cluster = clusters$cluster, .after = berg_anteil) %>%
  st_as_sf() # force to sf for plotting

# plotting code
tm_shape(gemeinden_clus) + 
  # fill geometries based on the cluster assigned
  tm_fill(col = "cluster", 
          style = "cat", 
          palette = c("orange", "navy", "whitesmoke"),
          legend.show = F) + 
  # add municipality borders
  tm_borders(col = "black", 
             lwd = 2) +
  # add legend
  tm_add_legend(col = c("Orange", "darkblue", "grey"), 
                labels = c("1", "2", "3"),
                title = "Clusters") +
  # add title
  tm_layout(main.title = "Merkmale der Gemeinden", 
            main.title.fontface = 2,fontfamily = "Arial",main.title.size =
              1.2, 
            legend.outside = TRUE,legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", type = 'text', legend.format = list(title.size = 0.1))
```
Abbildung 13: Visualisierung der Cluster auf einer Karte von Salzburg. 

Die Gemeinden, die zum Cluster 1 gehören, haben die höchste Bevölkerungsdichte, den geringsten Anteil an solaranlagegeeigneten Flächen, Grünland und Berggebieten sowie den höchsten Anteil an bewohnten Flächen (siehe Abb. 13). Gemeinden im Cluster 2 haben den höchsten Anteil an solaranlagegeeigneten Flächen und Grünland, einen mittleren Anteil an bewohnten Gebieten und eine moderate Bevölkerungsdichte. Cluster 3 umfasst Gemeinden mit der niedrigsten Bevölkerungsdichte und dem niedrigsten Anteil an bewohnter Fläche und Berggebieten mit Cluster 2. Der Anteil an Flächen, die für die Installation von Solaranlagen geeignet sind, ist ebenfalls niedrig, aber nicht so niedrig wie in Cluster 1. Im Gegenteil ist der Berganteil in diesen Gemeinden am höchsten. Der Grünlandanteil in Cluster 3 ist moderat. 

## Statistische Modellierung

```{r, eval=TRUE}
#### Statistically explore the relationship between these variables ----

# build a linear model based
fit <- lm(solar_anteil ~ gruenland_anteil + bewohnt_anteil + berg_anteil + einwohnerzahl_pro_qkm, gemeinden_data)

# look at fit of linear model
summary(fit)
```

Wenn man die Modellzusammenfasung betrachtet, sind zwei Variablen, der Grünlandanteil und der Berganteil, signifikant (p-Wert < 0.05). Das Modell zeigt, dass der Berganteil einer Gemeinde einen starken negativen Einfluss auf den Anteil der solaranlagegeeigneten Fläche hat. Hingegen hat der Grünlandanteil einer Gemeinde einen leichten positiven Einfluss auf den Anteil der solaranlagegeeigneten Fläche. Die Bevölkerungsdichte hat kaum Einfluss, aber der Anteil bewohntes Gebiet hat einen kleinen negativen Einfluss auf den Anteil der solaranlagegeeigneten Fläche. Jedoch sind diese Einflüße von der Bevölkerungsdichte und dem Anteil des bewohnten Gebiet nicht signifikant.

## Politische Durchführbarkeit

Obwohl der Fokus dieser Studie nicht an den sozialen Faktoren der Errichtung von Solaranlagen liegt, lässt sich diese Angelegenheit nicht vermeiden. Klimapolitik und erneuerbare Energiesysteme werden von Menschen, die andere Menschen und die Umwelt schätzen oder egalitäre Weltanschauungen, linke oder grüne politische Ideologien unterstützen, eher akzeptiert (Drews und Van den Bergh, 2016). Im Gegensatz dazu sind sie für Menschen, die Werte der Selbsterhöhung vertreten oder individualistische und hierarchische Weltanschauungen unterstützen, weniger akzeptabel (Dietz et al., 2007; Perlaviciute und Steg, 2014; Drews und Van den Bergh, 2016). Deswegen könnte ein Einblick in die politische Ausrichtung der Gemeinden  zeigen, ob der Ausbau der Solarenergie in Salzburg von der Bevölkerung akzeptiert wird.
```{r, eval=TRUE}
#### ---------------------------- Election Map ---------------------------- ####

# select data from gemeinden_data on elections and add a row containing strongest party in each municipality
ltw_geo <- gemeinden_data %>%
  select(c(1:2, 15:22, 33)) %>%
  rename_with(~str_remove(., "_prozent"), ends_with("_prozent")) %>%
  rename(Gruene = GRUENE) %>%
  rowwise() %>%
  mutate(staerkste_partei = names(.)[which.max(c_across(3:10))+2], .after = MFG)

# create function to calculate winning margin of winning party in each municipality
gewinspanne_func <- function(reihe) {
  reihe_sortiert <- sort(as.numeric(reihe), decreasing = TRUE)
  differenz <- reihe_sortiert[1] - reihe_sortiert[2]
  return(differenz)
}

# add a row to ltw_geo with the winning margin of winning party in each municipality
ltw_geo$gewinnspanne <- apply(ltw_geo[, -c(1:2, (ncol(ltw_geo) - 1):ncol(ltw_geo))], 1, gewinspanne_func)

# reorder columns and add columns for each winning party and their winning margins
ltw_geo <- ltw_geo %>%
  select(c(1:11, 13, 12)) %>%
  mutate(OeVP_gemeinden = ifelse(staerkste_partei == "OeVP", gewinnspanne, NA),
         FPOe_gemeinden = ifelse(staerkste_partei == "FPOe", gewinnspanne, NA),
         SPOe_gemeinden = ifelse(staerkste_partei == "SPOe", gewinnspanne, NA),
         .after = staerkste_partei)
```

```{r, eval=TRUE}
# transform layers to 4326 for plotting
ltw_geo_4326 <- st_transform(ltw_geo, "EPSG: 4326")

# create three new dataframes for the winning parties
oevp <- ltw_geo_4326 %>% 
  filter(complete.cases(OeVP_gemeinden))

fpoe <- ltw_geo_4326 %>% 
  filter(complete.cases(FPOe_gemeinden))

spoe <- ltw_geo_4326 %>% 
  filter(complete.cases(SPOe_gemeinden))


# create palette to display party winning margins
min_max_werte <- range(ltw_geo$gewinnspanne, na.rm = TRUE)
oevp_palette <- colorNumeric(palette = "Greys", 
                              domain=c(min_max_werte[1], min_max_werte[2]))
fpoe_palette <- colorNumeric(palette = "Blues", 
                                domain=c(min_max_werte[1], min_max_werte[[2]]))
spoe_palette <- colorNumeric(palette = "Reds", 
                              domain=c(min_max_werte[1], min_max_werte[2]))
```

```{r, eval=TRUE}
leaflet() %>%
  setView(lng = 13.5, lat = 47.5, zoom = 8.4) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(
    data = oevp,
    fillColor = ~oevp_palette(oevp$OeVP_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1,
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  oevp$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(oevp$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(oevp$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(oevp$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(oevp$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(oevp$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(oevp$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(oevp$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(oevp$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = fpoe,
    fillColor = ~fpoe_palette(fpoe$FPOe_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1,
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  fpoe$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(fpoe$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(fpoe$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(fpoe$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(fpoe$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(fpoe$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(fpoe$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(fpoe$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(fpoe$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = spoe,
    fillColor = ~spoe_palette(spoe$SPOe_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1, 
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  spoe$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(spoe$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(spoe$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(spoe$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(spoe$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(spoe$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(spoe$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(spoe$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(spoe$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addLegendNumeric(pal = spoe_palette, values = ~min_max_werte, title = "SPÖ
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = spoe) %>%
  addLegendNumeric(pal = fpoe_palette, values = ~min_max_werte, title = "FPÖ
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = fpoe) %>%
  addLegendNumeric(pal = oevp_palette, values = ~min_max_werte, title = "ÖVP
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = oevp)
```
Abbildung 14: Die 2023 Landtagswahlergebnisse pro Gemeinde. Die Pop Ups zeigen des erreichten Anteils jeder Partei in den jeweilgien Gemeinden. 

Bei der Landtagswahl 2023 erhielt die ÖVP in den meisten Gemeinden die meisten Stimmen. Die FPÖ (Freiheitliche Partei Österreichs) war die zweitgrößte Partei und die SPÖ (Sozialdemokratische Partei Österreichs) die dritterfolgreichste (siehe Abb. 14). Bei der Visualisierung gehen explizite Informationen zu den Stimmen von Parteien verloren, die in einer Gemeinde nicht den ersten Platz belegen. 

# Diskussion

talk about areas, where and what and what impact the urbanness and grassland has
Also limitations with study e.g. resolution of data, landcover, lamd use categories, other things, Fläche fragmentiert - noch eeine Kriteria wäre nützlich? Not the most up to date flächenwidmungsplan - but the only publically available

Compare grassland, residential area and solar maps with each other

The z-score is a standardised value relating to whether high values or low values are clustering together, which we call the Gi* statistic. (Gi-statistic)

The method used to choose the breaks for the chloropeth maps

Grassland - flatter areas with no mountains

Cluster also shows grassland and higher solar - also talk about urban areas and mountains and linkages between all these

Talk about model results- # critiques - ofc when include these factors in criteria they likely to have effect, but interesting to see what effect and the significance


Feasibility of using land for both agriculture and solar production can increase when both opitions combined (Calvin et al., 2023)

Social acceptance needs be addressed by renewable energy projects (Pao, 2023)

Talk about the importance of looking at the geographical spread of support as it is those who are directly affected by the building of a solar plant that are going to be most strongly in favour or opposition to it. Die Grünen sind großer Befürwörter der intensiveren Nutzung erneuerbarer Energie (Wenz, 2022). Talk about other parties and egalitarian and individualistic views. Then talk about nedled to take into societal factors - but this for future study - link to social tech trans

Public opposition may result from a culturally valued landscape being affected by adaptation or mitigation options, such as renewable energy development (Warren et al., 2005; Devinewright and Howes, 2010) - something to be considered in the cultural landscape on Austria - dealt with in another study

# Fazit und Aussicht

roof solar, social issues, looking at future - orientated based on newset Flächenwidmungplan even if areas are currently being used for different purpose

Doesn’t consider roof potential pv and also on train tracks

# Literaturverzeichnis

Alt, F. 2021. Nach Paris: Warum uns die Energiewende zu Gewinnern macht *In*: A. Hildebrandt and W. Landhäußer, eds. *CSR und Digitalisierung* [Online]. Management-Reihe Corporate Social Responsibility. Berlin, Heidelberg: Springer Berlin Heidelberg, pp.477–483. [Zugriff am 5. März 2024]. Verfügbar unter: http://link.springer.com/10.1007/978-3-662-61836-3_33.

Arán Carrión, J., Espín Estrella, A., Aznar Dols, F., Zamorano Toro, M., Rodríguez, M. and Ramos Ridao, A. 2008. Environmental decision-support systems for evaluating the carrying capacity of land areas: Optimal site selection for grid-connected photovoltaic power plants. *Renewable and Sustainable Energy Reviews*. 12(9), pp.2358–2380.

Arnette, A.N. and Zobel, C.W. 2011. Spatial analysis of renewable energy potential in the greater southern Appalachian mountains. *Renewable Energy*. 36(11), pp.2785–2798.

Beierle, T.C. 1998. *Public Participation in Environmental Decisions: An Evaluation Framework Using Social Goals* [Online]. Resources for the Future. Verfügbar unter: https://ideas.repec.org/p/ags/rffdps/10497.html.

*Bundesgesetz über den Ausbau von Energie aus erneuerbaren Quellen (Erneuerbaren-Ausbau-Gesetz – EAG), BGBl I 150/2021.* [Online].[Zugriff am 4. März 2024]. Verfügbar unter: https://www.ris.bka.gv.at/Dokumente/BgblAuth/BGBLA_2021_I_150/BGBLA_2021_I_150.html

Bußjäger, P. 2016. Die bundesstaatliche Kompetenzverteilung in Österreich *In*: A. Gamper, P. Bußjäger, F. Karlhofer, G. Pallaver and W. Obwexer, eds. *Föderale Kompetenzverteilung in Europa*. Baden-Baden: Nomos, pp.523–574.

Calvin, K., Dasgupta, D., Krinner, G., Mukherji, A., Thorne, P.W., Trisos, C., Romero, J., Aldunce, P., Barrett, K., Blanco, G., Cheung, W.W.L., Connors, S., Denton, F., Diongue-Niang, A., Dodman, D., Garschagen, M., Geden, O., Hayward, B., Jones, C., Jotzo, F., Krug, T., Lasco, R., Lee, Y.-Y., Masson-Delmotte, V., Meinshausen, M., Mintenbeck, K., Mokssit, A., Otto, F.E.L., Pathak, M., Pirani, A., Poloczanska, E., Pörtner, H.-O., Revi, A., Roberts, D.C., Roy, J., Ruane, A.C., Skea, J., Shukla, P.R., Slade, R., Slangen, A., Sokona, Y., Sörensson, A.A., Tignor, M., Van Vuuren, D., Wei, Y.-M., Winkler, H., Zhai, P., Zommers, Z., Hourcade, J.-C., Johnson, F.X., Pachauri, S., Simpson, N.P., Singh, C., Thomas, A., Totin, E., Arias, P., Bustamante, M., Elgizouli, I., Flato, G., Howden, M., Méndez-Vallejo, C., Pereira, J.J., Pichs-Madruga, R., Rose, S.K., Saheb, Y., Sánchez Rodríguez, R., Ürge-Vorsatz, D., Xiao, C., Yassaa, N., Alegría, A., Armour, K., Bednar-Friedl, B., Blok, K., Cissé, G., Dentener, F., Eriksen, S., Fischer, E., Garner, G., Guivarch, C., Haasnoot, M., Hansen, G., Hauser, M., Hawkins, E., Hermans, T., Kopp, R., Leprince-Ringuet, N., Lewis, J., Ley, D., Ludden, C., Niamir, L., Nicholls, Z., Some, S., Szopa, S., Trewin, B., Van Der Wijst, K.-I., Winter, G., Witting, M., Birt, A., Ha, M., Romero, J., Kim, J., Haites, E.F., Jung, Y., Stavins, R., Birt, A., Ha, M., Orendain, D.J.A., Ignon, L., Park, S., Park, Y., Reisinger, A., Cammaramo, D., Fischlin, A., Fuglestvedt, J.S., Hansen, G., Ludden, C., Masson-Delmotte, V., Matthews, J.B.R., Mintenbeck, K., Pirani, A., Poloczanska, E., Leprince-Ringuet, N. and Péan, C. 2023. *IPCC, 2023: Climate Change 2023: Synthesis Report. Contribution of Working Groups I, II and III to the Sixth Assessment Report of the Intergovernmental Panel on Climate Change [Core Writing Team, H. Lee and J. Romero (eds.)]. IPCC, Geneva, Switzerland*. [Online] First. Intergovernmental Panel on Climate Change (IPCC). [Zugriff am 7. März 2024]. Verfügbar unter: https://www.ipcc.ch/report/ar6/syr/.

Castillo, C.P., Silva, F.B. e and Lavalle, C. 2016. An assessment of the regional potential for solar power generation in EU-28. Energy Policy. 88, pp.86–99.
Decker, L.A. 2019. Climate Change Must Be Taken Seriously. *Natural Resources & Environment*. 33(4), pp.54–55.

Dietz, T., Dan, A. and Shwom, R. 2007. Support for Climate Change Policy: Social Psychological and Social Structural Influences* . *Rural Sociology*. 72(2), pp.185–214.
Drews, S. and Bergh, J.C.J.M. van den 2016. What explains public support for climate policies? A review of empirical and experimental studies. Climate Policy. 16(7), pp.855–876.

Fechner, H. 2020. *Ermittlung des Flächenpotentials für den Photovoltaik-Ausbau in Österreich: Welche Flächenkategorien sind für die Erschließung von besonderer Bedeutung, um das Ökostromziel realisieren zu können.*

Geels, F.W., Sovacool, B.K., Schwanen, T. and Sorrell, S. 2017. The Socio-Technical Dynamics of Low-Carbon Transitions. *Joule*. 1(3), pp.463–479.

Gingrich, S. 2023. Civil society initiatives W. Winiwarter & V. J. Bruckman, eds. *KIOES Opinions*. (13), pp.19–20.

IPCC 2022. *Global Warming of 1.5°C: IPCC Special Report on Impacts of Global Warming of 1.5°C above Pre-industrial Levels in Context of Strengthening Response to Climate Change, Sustainable Development, and Efforts to Eradicate Poverty* [Online]. Cambridge University Press. [Zugriff am 9. März 2024]. Verfügbar unter: https://www.cambridge.org/core/product/identifier/9781009157940/type/book.

Kerber, F. 2022. *Eine Solarpotentialanalyse der Gebäudedachflächen für die Stromerzeugung aus Photovoltaik für die Regionen Kärnten, Salzburg, Steiermark und Tirol.* Karl-Franzens-Universität Graz.

Kereush, D. and Perovych, I. 2017. Determining Criteria For Optimal Site Selection For Solar Power Plants. *Geomatics, Landmanagement and Landscape*. 4, pp.39–54.

Kettner, C., Böheim, M., Sommer, M., Gaugl, R., Bachhiesl, U., Gruber, L., Klatzer, T.F., Wogrin, S. and Kratena, K. 2024. Transformation to a renewable electricity system in Austria: Insights from an integrated model analysis. *Renewable Energy*. 223, p.119957.

Kowalski, K. 2010. *Sustainable Energy Transitions in Austria*.[Online] University of Sussex. Verfügbar unter: https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=825690510e98bc022ed338fc991eeec7cf0d0ad0.

Land Sazlburg 2024. Klima- und Energiestrategie SALZBURG 2050 - Land Salzburg. [Zugriff am 4. März 2024]. Verfügbar unter: https://www.salzburg.gv.at/themen/umwelt/salzburg2050/klima_energie.

Land Sazlburg 2021. *Masterplan Klima+Energie 2030 - Bericht Oktober 2021* [Online]. Sazlburg: Land Salzburg. [Zugriff am 4. März 2024]. Verfügbar unter: https://www.salzburg.gv.at/umweltnaturwasser_/Documents/Umwelt/MasterplanKlimaEnergie2030.pdf.

Mierzwiak, M. and Calka, B. 2017. Multi-Criteria Analysis for Solar Farm Location Suitability. *Reports on Geodesy and Geoinformatics*. 104(1), pp.20–32.

Mokarram, M., Mokarram, M.J., Khosravi, M.R., Saber, A. and Rahideh, A. 2020. Determination of the optimal location for constructing solar photovoltaic farms based on multi-criteria decision system and Dempster–Shafer theory. *Scientific Reports*. 10(1), p.8200

Pao, L.Y. 2023. Potentials and limitation of regenerative power: Hydro, wind, and solar W. Winiwarter & V. J. Bruckman, eds. *KIOES Opinions*. (13), pp.25–27.

Perlaviciute, G. and Steg, L. 2014. Contextual and psychological factors shaping evaluations and acceptability of energy alternatives: Integrated review and research agenda. *Renewable and Sustainable Energy Reviews*. 35, pp.361–381.

Riahi, K. 2023. Energy Transition Pathways W. Winiwarter & V. J. Bruckman, eds. *Energy Transition for a sustainable society*. (13), pp.7–10.

*Richtlinie 2009/28/EG des Europäischen Parlaments und des Rates vom 23. April 2009 zur Förderung der Nutzung von Energie aus erneuerbaren Quellen und zur Änderung und anschließenden Aufhebung der Richtlinien 2001/77/EG und 2003/30/EG*. [Online]. [Zugriff am 4. März 2024]. Verfügbar unter: https://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2009:140:0016:0062:de:PDF

Rowe, G. and Frewer, L.J. 2000. Public Participation Methods: A Framework for Evaluation. *Science, Technology, & Human Values*. 25(1), pp.3–29.

Sareen, S. and Haarstad, H. 2018. Bridging socio-technical and justice aspects of sustainable energy transitions. *Applied Energy*. 228, pp.624–632.

Schneider, U. 2023. Kapitel 18. Sozialstaat und Klimawandel *In*: C. Görg, V. Madner, A. Muhar, A. Novy, A. Posch, K. W. Steininger and E. Aigner, eds. *APCC Special Report: Strukturen für ein klimafreundliches Leben* [Online]. Berlin, Heidelberg: Springer Berlin Heidelberg, pp.499–528. [Zugriff am 5. März 2024]. Verfügbar unter: https://link.springer.com/10.1007/978-3-662-66497-1_22.

Spreer, J. 2023. PV-Anlagen bringen Landwirten zehnmal mehr als Ackeranbau. *Der Standard*. [Online]. [Zugriff am 15. März 2024]. Verfügbar unter: https://www.derstandard.de/story/3000000188740/pv-anlagen-bringen-landwirten-zehnmal-mehr-als-ackeranbau.

*Verordnung der Salzburger Landesregierung vom 19. Oktober 2023, über die Erlassung einer Photovoltaik-Kennzeichnungsverordnung und die Änderung der Darstellungsverordnung für Flächenwidmungs- und Bebauungspläne, LGBl 73/2023.* [Online].[Zugriff am 4. März 2024]. Verfügbar unter: https://www.ris.bka.gv.at/Dokumente/LgblAuth/LGBLA_SA_20231024_73/LGBLA_SA_20231024_73.html

*Verordnung (EU) 2021/1119 des Europäischen Parlaments und des Rates vom 30. Juni 2021 zur Schaffung des Rahmens für die Verwirklichung der Klimaneutralität und zur Änderung der Verordnungen (EG) Nr. 401/2009 und (EU) 2018/1999 („Europäisches Klimagesetz“).* [Online]. [Zugriff am 4. März 2024]. Verfügbar unter: https://eur-lex.europa.eu/legal-content/DE/TXT/PDF/?uri=CELEX:32021R1119&from=FR

Wenz, N. 2022. Energy Governance in Austria *In*: M. Knodt and J. Kemmerzell, eds. *Handbook of Energy Governance in Europe* [Online]. Cham: Springer International Publishing, pp.455–482. [Zugriff am 5. März 2024]. Verfügbar unter: https://link.springer.com/10.1007/978-3-030-43250-8_2.

Winiwarter, V., Baumgarten, A., Berg, Ch., Blöschl, G., Fürnkranz-Prskawetz, A., Kasper-Giebl, A., Kromb-Kolb, H., Jandl, R., Sturmbauer, Ch., Strauß, J., Striessnig, E. and Zechmeister-Boltenstern, S. 2018. Vermächtnisrisiken in Österreich als Herausforderung für die Umsetzung der Agenda 2030 V. Winiwarter, ed. *KIOES Opinions*. (8), pp.93–98.



