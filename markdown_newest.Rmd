---
title: "Energiewende in Sazlburg - Potenziale Solaranlagen"
author: "Timothy Sung"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```

Die Entwicklung des Klimas in den letzten Jahrhundert (Klimawandel Intro - Umbruch
andere Denkweise und Ansätze) - IPCC Berichte - Energiewende einen großen Teil 
der aktuellen Herausforderung, falls die besseser Pathways eingehalten werden wollen.  EU und AT haben diese Herausforderung annerkant, aber müssen noch handeln - (nicht so politisch)

![Abbildung 1: Klima- und Energiestrategie SALZBURG 2050 (Land Salzburg, 2021)](offline_files/masterplan_klima_bild.png)

<style>
    table {
        border-collapse: collapse;
        width: 100%;
    }

    th, td {
        border: 0.5px solid black;
        padding: 8px;
        text-align: left;
    }

    th:first-child, td:first-child {
        border-right: 2px solid black;
    }

    tr:first-child td {
        border-top: 2px solid black;
    }

    tr:nth-child(2) td{
        border-top: 2px dashed black;
    }
    tr:nth-child(9) td:first-child {
    border-top: 2px dashed black;
    border-bottom: 2px dashed black;
    }
    
    tr:nth-child(9) td:last-child {
    border-top: 2px dashed black;
    border-bottom: 2px dashed black;
    }
    tr:nth-child(1) td {
        border-right: none;
        border-right: 0.5px solid black;
    }
    tr:nth-child(9) td {
        border-right: none;
        border-right: 0.5px solid black;
    } 
    
    tr:nth-child(1) td:nth-child(2) {
        border: none; /* Remove borders for the second column in the second row */
    }
    tr:nth-child(9) td:nth-child(2) {
        border: none; /* Remove borders for the second column in the second row */
    }
    
</style>

Tabelle 1: Kriterien berücksichtigt für Solaranlagenflächen (Adaptiert von Kereush & Perovych, 2017)
<table>
  <thead>
    <tr>
      <th>Kriterien</th>
      <th>Voraussetzung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td colspan="2"><i>Evaluierungskriterien</i></td>
      <td></td>
    </tr>
    <tr>
      <td>Ausreichende Solareinstrahlung</td>
      <td>Minimum 1100 kWh/m<sup>2</sup>/Jahr</td>
    </tr>
    <tr>
      <td>Hangneigung</td>
      <td>&lt; 15&deg;</td>
    </tr>
    <tr>
      <td>Hangausrichtung</td>
      <td>110-200&deg; (Südost, Süd, teils Südwest) <br>Wenn die Hangneigung unter 3.5&deg; ist, kann die Anlage in irgendwelche Richtung ausrichtet werden</td>
    </tr>
    <tr>
      <td>Nähe zu bewohnten Gebieten</td>
      <td>&lt; 2500 m</td>
    </tr>
    <tr>
      <td>Nähe zu Betrieben</td>
      <td>&lt; 3500 m</td>
    </tr>
    <tr>
      <td>Nähe zum Straßennetz</td>
      <td>&lt; 500 m</td>
    </tr>
    <tr>
      <td>Nähe zum Wohnegebiete</td>
      <td>\> 500 m</td>
    </tr>
    <tr>
      <td colspan="2"><i>Auschlusskriterien</i></td>
      <td></td>
    </tr>
    <tr>
      <td>Landabdeckung</td>
      <td>• Frei von Bergen, Wäldern, Gewässern, Gebäuden und Feuchtgebieten <br>• Bevorzugt: Grünland und Agrarfläche</td>
    </tr>
    <tr>
      <td>Schutzgebiete</td>
      <td>Schutzgebiete ausgewiesen vom Land, Bund und EU</td>
    </tr>
    <tr>
      <td>Höhenlage</td>
      <td>\> 1500 m</td>
    </tr>
    <tr>
      <td>Bahnstrecken</td>
      <td>Darf nicht überschneiden</td>
    </tr>
  </tbody>
</table>

```{r install libraries}
# Install the required libraries if not already installed
if (!requireNamespace("tmap", quietly = TRUE)) {
  install.packages("tmap")
}
if (!requireNamespace("raster", quietly = TRUE)) {
  install.packages("raster")
}
if (!requireNamespace("terra", quietly = TRUE)) {
  install.packages("terra")
}
if (!requireNamespace("stars", quietly = TRUE)) {
  install.packages("stars")
}
if (!requireNamespace("sp", quietly = TRUE)) {
  install.packages("sp")
}
if (!requireNamespace("sf", quietly = TRUE)) {
  install.packages("sf")
}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}
if (!requireNamespace("janitor", quietly = TRUE)) {
  install.packages("janitor")
}
if (!requireNamespace("leaflet", quietly = TRUE)) {
  install.packages("leaflet")
}
if (!requireNamespace("leaflet.extras", quietly = TRUE)) {
  install.packages("leaflet.extras")
}
if (!requireNamespace("cluster", quietly = TRUE)) {
  install.packages("cluster")
}
if (!requireNamespace("readr", quietly = TRUE)) {
  install.packages("readr")
}
if (!requireNamespace("factoextra", quietly = TRUE)) {
  install.packages("factoextra")
}
if (!requireNamespace("stringr", quietly = TRUE)) {
  install.packages("stringr")
}
if (!requireNamespace("spdep", quietly = TRUE)) {
  install.packages("spdep")
}
if (!requireNamespace("units", quietly = TRUE)) {
  install.packages("units")
}
if (!requireNamespace("RColorBrewer", quietly = TRUE)) {
  install.packages("RColorBrewer")
}
if (!requireNamespace("basemaps", quietly = TRUE)) {
  install.packages("basemaps")
}
if (!requireNamespace("tmaptools", quietly = TRUE)) {
  install.packages("tmaptools")
}
if (!requireNamespace("nominatimlite", quietly = TRUE)) {
  install.packages("nominatimlite")
}
if (!requireNamespace("knitr", quietly = TRUE)) {
  install.packages("knitr")
}
if (!requireNamespace("kableExtra", quietly = TRUE)) {
  install.packages("kableExtra")
}
if (!requireNamespace("extrafont", quietly = TRUE)) {
  install.packages("extrafont")
}
if (!requireNamespace("tinytex", quietly = TRUE)) {
  install.packages("tinytex")
}
if (!requireNamespace("leaflegend", quietly = TRUE)) {
  install.packages("leaflegend")
}
```


```{r load libraries, eval=TRUE}
library(tmap)
library(raster)
library(terra)
library(stars)
library(sp)
library(sf)
library(tidyverse)
library(janitor)
library(leaflet)
library(leaflet.extras)
library(cluster)
library(readr)
library(factoextra)
library(stringr)
library(spdep)
library(units)
library(RColorBrewer)
library(basemaps)
library(tmaptools)
library(nominatimlite)
library(knitr)
library(kableExtra)
library(extrafont)
library(tinytex)
library(leaflegend)
```

## Dateneinlesen

```{r, eval = TRUE}
# set working directory
setwd("/Volumes/SD_Backup/GIS_Project")
```

```{r}
#### ----------- Data Download and CRS Check and Transformation ----------- ####
# read in solar potential data ----
solar_raw <- rast("offline_files/Solarpot/solarpot_31258.tif")
```

```{r, eval = TRUE, results = FALSE}
# download data on municipality borders and populations, and create state border polygon  ----
# download raw data on municipality borders 
gem_grenz_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/ESRI_SHAPE/Gemeindegrenzen.shp")

# download data on municipality populations ----
pop_raw <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Bev_2023_nach_Katastralgemeinden.csv",
                    # skip first row so that columns names are the headers
                    skip = 1) 

# create a polygon with the boundaries of Sazlburg state
bundesland <- gem_grenz_raw %>%
  # generate IDs for grouping
  mutate(merge_id = 1) %>% 
  group_by(merge_id) %>%
  summarise(geometry = sf::st_union(geometry)) %>%
  ungroup()
```

```{r, eval=TRUE, results = FALSE}
#### -------------------------- Map of Salzburg --------------------------- ####
# add data on counties
bezirke <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/vgd/Salzburg_BEV_VGD_LAM.shp")

# change bezirke$GKZ to numeric to match joining row's format
bezirke$GKZ <- as.numeric(bezirke$GKZ)

# combine with spatial df on Gemeinde - join information on counties
bezirk_list <- gem_grenz_raw %>%
  left_join(dplyr::select(as_tibble(bezirke), "PB", "GKZ"), 
            by = c("GEMNR" = "GKZ")) %>%
  distinct(GEMNR, .keep_all = TRUE) %>%
  # change names of Bezirke to traditional areas
  mutate(PB = case_when(          
    PB == "Salzburg-Umgebung" ~ "Flachgau",
    PB == "Hallein" ~ "Tennengau",
    PB == "Salzburg(Stadt)" ~ "Salzburg (Stadt)",
    PB == "Sankt Johann im Pongau" ~ "Pongau",
    PB == "Zell am See" ~ "Pinzgau",
    PB == "Tamsweg" ~ "Lungau")) %>%
  # for ordering in map legend
  mutate(PB = factor(PB, levels = c("Salzburg (Stadt)", "Flachgau", "Tennengau",
                                    "Pongau", "Pinzgau", "Lungau"))) 
                                  

# combine geometries of indiviual municpalities to get geometries for counties
bezirk_grenz <- bezirk_list %>%
  group_by(PB) %>%
  summarise(geometry = sf::st_union(geometry)) %>%
  ungroup()
```

```{r, eval=TRUE, results = FALSE}
# Prepare data for plotting
# transform gem_grenz_raw to OSM CRS
gem_grenz_raw_3857 <- st_transform(gem_grenz_raw, "EPSG: 3857")

# extract map for inset map based on extent of gem_grenz_raw_3857
osm_sbg <- read_osm(gem_grenz_raw_3857, type = "esri-natgeo", ext=7)

# transform back to working CRS - EPSG:31258
osm_sbg <- st_transform(osm_sbg, "EPSG: 31258")

# create polygon to crop transformed inset map
bbox_inset <- bbox_to_poly(bbox = c(-59991.8259,-143180.5017,896875.9305,
                                    548802.6460), crs = 31258)

# crop osm_sbg to extent of bbox
osm_sbg <- st_crop(osm_sbg, bbox_inset)

# extract bbox from gem_grenz_raw
sbg_bbox <- st_bbox(gem_grenz_raw)

# use sbg_bbox to create a polygon to highlight area of interest in inset map
aoi_inset <- bbox_to_poly(sbg_bbox, crs = 31258)
```

```{r, eval = TRUE, fig.align='center'}
# Salzburg Map Plot Code

# create inset map
inset_karte<- tm_shape(osm_sbg) + 
  tm_rgb() +
  tm_shape(aoi_inset) +
  tm_borders(col="red", lwd = 3) +
  tm_layout(frame = F, bg.color = "transparent")

# create map of Salzburg with county and municipality boundaries
sbg_karte <-tm_shape(bezirk_grenz) + 
  tm_fill(col = "PB",
          # give each county a different fill shade
          palette = brewer.pal(6,"Set1"),
          legend.show = F) +
  # add borders of counties  
  tm_borders(lwd = 4,                 
             col = "black") +
  tm_shape(gem_grenz_raw) +
  # add shape and border of municipalities
  tm_polygons(alpha = 0,             
              lwd = 1,
              col = "black") +
  # add legend for county fill
  tm_add_legend(col = brewer.pal(6,"Set1"),  
                # custom ordering of counties in legend
                labels = c("Salzburg (Stadt)", "Flachgau", "Tennengau", 
                           "Pongau", "Pinzgau", "Lungau" ), 
                title = "Bezirke") + 
  # add legend for county borders
  tm_add_legend(type = "line", 
                lwd = 4,
                col = "black",
                labels = "Bezirksgrenzen") +
  # add legend for municipality borders
  tm_add_legend(type = "line", 
                lwd = 1,
                col = "black",
                labels = "Gemeindegrenzen") + 
  tm_layout(legend.outside = TRUE, # place legend outside of map frame
            legend.text.size = 0.75, 
            legend.position = c("left","top"), # determine legend position
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02)) +
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESRI", type = 'text', legend.format = list(title.size = 0.1))

# print map
sbg_karte
print(inset_karte, vp = grid::viewport(0.83, 0.15, width = 0.3, height = 0.53))

```

```{r, eval=TRUE}
# extract the municipalities belonging to Salzburg (Stadt) to a tibble 
salzburg_stadt_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Salzburg (Stadt)")

# extract the municipalities belonging to Flachgau to a tibble 
flachgau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Flachgau")

# extract the municipalities belonging to Tennengau to a tibble 
tennengau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Tennengau")

# extract the municipalities belonging to Pongau to a tibble 
pongau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Pongau")

# extract the municipalities belonging to Pinzgau to a tibble 
pinzgau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Pinzgau")

# extract the municipalities belonging to Lungaug to a tibble 
lungau_df <- (as_tibble(bezirk_list)) %>%
  filter(PB == "Lungau")

# create a knitr table with a list of counties and their municipalities
Salzburg_stadt <- kbl(select(salzburg_stadt_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Flachgau <- kbl(select(flachgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Tennengau <- kbl(select(tennengau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Pinzgau <- kbl(select(pinzgau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Pongau <- kbl(select(pongau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

Lungau <- kbl(select(lungau_df,c("PB", "NAME")), 
              col.names = c("Bezirk", "Gemeinde"), align = "c") %>%
  kable_paper(full_width = F) %>%
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1, valign = "top")

# reformat so that a new column is started for each different entry of bezirk
cat(c("\\begin{table}[!htb]
    \\begin{minipage}{.5\\linewidth}
      \\caption{}
      \\centering",
        Lungau,
    "\\end{minipage}%
    \\begin{minipage}{.5\\linewidth}
      \\centering
        \\caption{}",
        Pinzgau,
    "\\end{minipage} 
\\end{table}"
)) 

```

```{r, eval = TRUE, results = FALSE}
# read in data on the Landtagswahl 2023 ----
ltw_raw <- read_csv2("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master//LTW-2023.csv") #only first page of orignal data saved as csv

```

```{r}
# read in data on land cover, combine layers and amend CRS ----
lc_a_raw <- rast("offline_files/land_cover/ESA_WorldCover_10m_2021_v200_N45E012_Map.tif")
lc_b_raw <- rast("offline_files/land_cover/ESA_WorldCover_10m_2021_v200_N48E012_Map.tif")

# combine raster layers
lc_comb <- terra::merge(lc_a_raw, lc_b_raw)

# transform CRS to that of lc_comb - quicker than reprojecting both rasters
gem_grenz_4326 <- st_transform(gem_grenz_raw, "EPSG:4326") 

# crop lc data to Salzburg bb
lc_comb_sbg_bb <- terra::crop(lc_comb, gem_grenz_4326) 

# transfrom Salzburg boundaries to EPSG: 4326
bundesland_4326 <- st_transform(bundesland, "EPSG:4326") 

# mask lc data to Salzburg
lc_comb_sbg <- terra::mask(lc_comb, bundesland_4326)

# re-project lc_comb_sbg to working CRS
lc_sbg <- project(lc_comb_sbg, "EPSG: 31258")
```

```{r, include = FALSE}
# write out raster to save time on processing
writeRaster(lc_sbg, "daten_zwischenablage/lc_sbg.tif", overwrite = TRUE) 
```

```{r, eval = TRUE, results = FALSE}
# read in data on zoning ----
fl_wid_raw <- st_read("offline_files/Flaechenwidmung/Flaechenwidmung.shp")
```

```{r}
# read in digital surface model (topographical data) ----
dgm <- rast("offline_files/dgm5m/dgm5m.asc")

# convert to working crs of EPSG: 31258 
dgm <- project(dgm, "EPSG:31258")
```

```{r, include=FALSE}
# write out raster
writeRaster(dgm, "daten_zwischenablage/dgm.tif") # write out raster
```

```{r, eval = TRUE, results = FALSE}
#### Load data on protected areas

# download data on FFH sites ----
ffh_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_FFH_RL/Europaschutzgebiete_FFH_RL.shp")

# download data on other Natura 2000 sites ----
natura2000_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_Schutzzonen/Europaschutzgebiete_Schutzzonen.shp")

# download data on SPA sites ----
spa_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Europaschutzgebiete_VS_RL/Europaschutzgebiete_VS_RL.shp")

# download data on RAMSAR sites ----
ramsar_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Gebiete_gem_Ramsar_Konvention/Gebiete_gem_Ramsar_Konvention.shp")

# download data on protected landscape features ----
geschuezte_lt_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Geschuetzte_Landschaftsteile/Geschuetzte_Landschaftsteile.shp")

# download data on protected natural features ----
geschuezte_ng_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Geschuetzte_Naturgebilde/Geschuetzte_Naturgebilde.shp")

# download data on landscape protection areas ----
lsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Landschaftsschutzgebiete/Landschaftsschutzgebiete.shp")

# download data on National Park sites ----
np_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/NPHT_Land_Salzburg/NPHT_Land_Salzburg.shp")

# download data on natural monuments ----
nd_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Naturdenkmaeler/Naturdenkmaeler.shp")

# download data on nature conservation areas ----
nsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Naturschutzgebiete/Naturschutzgebiete.shp")

# download data on plant protection areas ----
psg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Pflanzenschutzgebiete/Pflanzenschutzgebiete.shp")

# download data on wildlife reserves ----
wsg_raw <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/Wild_Europaschutzgebiete_VS_RL/Wild_Europaschutzgebiete_VS_RL.shp")
```

## Weitere Datenbereinigung

```{r, eval = TRUE}
#### ------------------------ Further Data Cleaning ----------------------- ####
# clean the column names of all data frames and spatial data frames ----
# Get a list of all data frames in the global environment
df_list <- Filter(is.data.frame, mget(ls()))

# Loop through each data frame, apply clean_names(), and rename the data frame by removing _raw and pasting _clean
for (df_name in names(df_list)) {
  # Apply clean_names() to the data frame
  cleaned_df <- clean_names(get(df_name))
  
  # Change the name by appending "_clean" and removing "_raw" if present
  new_name <- gsub("_raw", "", paste0(df_name, "_clean"))
  
  # Assign the cleaned data frame with the new name to the global environment
  assign(new_name, clean_names(get(df_name)))
  
  rm(cleaned_df)
}
```

```{r, eval = TRUE}
# merge together population data with geometry data of muncipality ----

# aggregate Kastralgemeinde population to the Gemeinde (municipal) level 
gemeinden <- pop_clean %>% 
  filter(bundesland == "Salzburg") %>%
  select(-c(4,5)) %>%
  rename(c(gkz = 2, bevoelkerung = 4)) %>%
  group_by(gemeindename, gkz) %>%
  summarise(bevoelkerung = sum(bevoelkerung)) %>%
  # merge with gem_grenz_raw on basis of municipality name & code
  right_join(gem_grenz_clean, by = c("gkz" = "gemnr", "gemeindename" = "name")) %>%
  st_as_sf() # reasign as sf object

```

```{r, eval = TRUE}
# merge together municipality data with Landtagswahl data from 2023
# clean ltw_raw
ltw <- ltw_clean %>%
  # rename columns
  rename(gemnr = 1, name = 2, OeVP = 9, SPOe = 11, FPOe = 13, GRUENE = 15, 
         NEOS = 17, KPOe = 19, WIRS = 21, MFG = 23) %>% 
  # remove rows which don't contain municipality level data
  filter(!row_number() %in% c(1:17, 137:nrow(ltw_clean))) %>% 
  dplyr::select(-c(3:8, 10, 12, 14, 16, 18, 20, 22, 24:ncol(ltw_clean))) %>% 
  # remove columns that contain percentage data, turnout values and those that contain no data !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # remove all the in columns containing vote data
  mutate_at(c(3:10), ~str_replace_all(., "\\.", "")) %>% 
  # set columns containing vote data to numeric
  mutate_at(c(3:10), as.numeric) %>% 
  # set to double to allow for joining with gemeinden later
  mutate_at(1, as.double) %>% 
  # sum up the total number of votes for each municipality
  mutate(total_stimmen = rowSums(across(OeVP:MFG))) %>% 
  # calculate percentage of votes for each party in each municipality
  mutate(OeVP_prozent = OeVP/total_stimmen*100, 
         SPOe_prozent = SPOe/total_stimmen*100,
         FPOe_prozent = FPOe/total_stimmen*100, 
         GRUENE_prozent = GRUENE/total_stimmen*100,
         NEOS_prozent = NEOS/total_stimmen*100,
         KPOe_prozent = KPOe/total_stimmen*100, 
         WIRS_prozent = WIRS/total_stimmen*100,
         MFG_prozent = MFG/total_stimmen*100, .after = MFG) 

# join ltw with gemeinden
gemeinden_ltw <- gemeinden %>%
  # join gemeinden with ltw based on the Gemeinde Nummer
  left_join(ltw, by = c("gkz" = "gemnr")) %>% 
  # reorder columns so geometry is last and delete names as this data is duplicated
  dplyr::select(c(1:7), c(9:26), 8, -name) 
  
```

```{r, eval = TRUE}
# merge datasets on protected areas together ----

# merge cleaned datasets using bind_rows 
pa_all <- bind_rows(ffh_clean, geschuezte_lt_clean, geschuezte_ng_clean, 
                    lsg_clean, natura2000_clean, nd_clean, np_clean,
                    nsg_clean,psg_clean, ramsar_clean, spa_clean, wsg_clean)
```

```{r, eval = TRUE}
# extract water, roads, train tracks, solar parks, populated areas, ---- 
# enterprise areas, and residential areas from fl_wid_clean

# check validity of all geometries and correct if not
if ("geometry" %in% names(fl_wid_clean)) {
  
  # Check validity of geometries
  invalid_geoms <- st_is_valid(fl_wid_clean$geometry)
  
  # If there are invalid geometries, correct them using st_make_valid
  if (any(!invalid_geoms)) {
    # Identify and correct invalid geometries
    fl_wid_clean$geometry[!invalid_geoms] <- st_make_valid(fl_wid_clean$geometry[!invalid_geoms])
    
  }
  
}

# extract data for water, roads, train tracks, populated areas, 
# enterprise areas and solar farms and add a key for these categories

# populated areas
fl_wid_bewohnt <- fl_wid_clean %>%
  filter(typname == "BARW" | typname == "BAEW" | typname == "BAFW" | 
           typname == "BAKG" | typname == "BALK" | typname == "BADG" | 
           typname == "BABE" | typname == "BAGG" | typname == "BAIG" | 
           typname == "BAZG" | typname == "BAHV" | typname == "BAHC" | 
           typname == "BAHF" | typname == "BAHB" | typname == "BAHE" | 
           typname == "BABG") %>%
  mutate(kategorie = "bewohnt")

# residnetial areas
fl_wid_wohngebiete <- fl_wid_clean %>%
  filter(typname == "BARW" | typname == "BAEW" | typname == "BAFW" | 
           typname == "BAKG" | typname == "BALK" | typname == "BADG" | 
           typname == "BAZG" | typname == "BABG") %>%
  mutate(kategorie = "wohngebiet")

# enterprise/industrial areas
fl_wid_betriebe <- fl_wid_clean %>%
  filter(typname == "BADG" | typname == "BABE" | typname == "BAGG" | 
           typname == "BAIG" | typname == "BAHV" | typname == "BAHC" | 
           typname == "BAHF" | typname == "BAHB" | typname == "BAHE" | 
           typname == "BABG" | typname == "GLMG") %>%
  mutate(kategorie = "betrieb")

# water 
fl_wid_gewaesser <- fl_wid_clean %>%
  filter(typname == "GLGG") %>%
  mutate(kategorie = "gewaesser")

# train tracks
fl_wid_bahn <- fl_wid_clean %>%
  filter(typname == "VEEB") %>%
  mutate(kategorie = "bahn")

# roads
fl_wid_str <- fl_wid_clean %>%
  filter(typname == "VEGM" | typname == "VEBL" | typname == "VESO") %>%
  mutate(kategorie = "strasse")

# solar farms
fl_wid_solar <- fl_wid_clean %>%
  filter(typname == "GLSA") %>%
  mutate(kategorie = "solar")

# combine these into a new spatial dataframe with a key for each zoning category
fl_wid_kat_alle <- bind_rows(list(fl_wid_bahn, fl_wid_betriebe,
                                  fl_wid_bewohnt, fl_wid_gewaesser,
                                  fl_wid_str, fl_wid_wohngebiete,
                                  fl_wid_solar))
```

## Puffer Erstellen, Festellung von ausgeschlossenen Gebieten

### Straßen

```{r}
#### -------------------------------- Roads ------------------------------- ####
# create buffer around roads
str_buffer <- fl_wid_kat_alle %>%
  # choose roads from df
  filter(kategorie == "strasse") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all road geometries into one polygon geometry
  st_union() %>% 
  # 500 m buffer around geometries
  st_buffer(500) %>% 
  # clip to size of state
  st_intersection(bundesland_clean) 
```

```{r, include=FALSE}
# write str_buffer to a shapefile
st_write(str_buffer, "daten_zwischenablage/str_buffer.shp", append = F)

# read in str_buffer
str_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/str_buffer.shp")
```

### Bewohnte Gebiete

```{r}
#### --------------------------- Populated Areas -------------------------- ####
# create buffer around populated areas

# combine all populated area geometries into one polygon geometry
bewohnt_buffer <- fl_wid_kat_alle %>%
  # choose populated areas from df
  filter(kategorie == "bewohnt") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all populated area geometries into one polygon geometry
  st_union() %>% 
  # 2500 m buffer around geometries
  st_buffer(2500)%>% 
  # clip to size of state
  st_intersection(bundesland_clean) 

```

```{r, include = FALSE}

# write bewohnt_buffer to a shapefile
st_write(bewohnt_buffer, "daten_zwischenablage/bewohnt_buffer.shp", append = F)

# read in bewohnt_buffer
bewohnt_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/bewohnt_buffer.shp")
```

### Wohngebiete

```{r}
#### -------------------------- Residential Areas ------------------------- ####
# create buffer around residential areas

# combine all residential area geometries into one polygon geometry
wohngebiete_buffer <- fl_wid_kat_alle %>%
  # choose residential areas from df
  filter(kategorie == "wohngebiet") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all residential area geometries into one polygon geometry
  st_union() %>% 
  # 500 m buffer around geometries
  st_buffer(500) %>% 
  # clip to size of state
  st_intersection(bundesland_clean) 
```

```{r, include = FALSE}
# write wohngebiete_buffer to a shapefile
st_write(wohngebiete_buffer, "daten_zwischenablage/wohngebiete_buffer.shp", 
         append = F)

# read in wohngebiete_buffer
wohngebiete_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/wohngebiete_buffer.shp")
```

### Betriebsgebiete

```{r}
#### --------------------- Enterprise/Indsutrial Areas -------------------- ####
# create buffer around enterprise/industrial areas

# combine all enterprise/industrial area geometries into one polygon geometry
betriebe_buffer <- fl_wid_kat_alle %>%
  # choose residential areas from df
  filter(kategorie == "betrieb") %>% 
  # select only the geometry column for spatial operations
  select(geometry) %>% 
  # combine all enterprise/industral area geometries into one polygon geometry
  st_union() %>% 
  # 3500 m buffer around geometries
  st_buffer(3500) %>% 
  # clip to size of stat
  st_intersection(bundesland_clean) e
```

```{r, include = FALSE}
# write betriebe_buffer to a shapefile
st_write(betriebe_buffer, "daten_zwischenablage/betriebe_buffer.shp", 
         append = F)

# read in betriebe_buffer
betriebe_buffer <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/betriebe_buffer.shp")
```

### Schutzgebiete

```{r, eval = TRUE}
#### --------------------------- Protected Areas -------------------------- #### 
# combine all polygons together on Protected Area Data

# check validity of all geometries and correct if not
if ("geometry" %in% names(pa_all)) {
  
  # Check validity of geometries
  invalid_geoms <- st_is_valid(pa_all$geometry)
  
  # If there are invalid geometries, correct them using st_make_valid
  if (any(!invalid_geoms)) {
    # Identify and correct invalid geometries
    pa_all$geometry[!invalid_geoms] <- st_make_valid(pa_all$geometry[!invalid_geoms])
    
  }
  
  # Join all protected area geometries into one multipolygon
  pa_comb <- st_union(pa_all$geometry)
  
} 
```

### Kombinieren von Vectorpuffern und ???

```{r}
#### ---------- Combine vector buffers and geometric conditions ----------- ####
# combine buffers outlining appropriate places - betriebe, bewohnt, str 
polygon_flaeche_geeignet_rein <- bind_rows(list(betriebe_buffer,
                                                bewohnt_buffer, 
                                                str_buffer)) %>%
  st_union()

# combine geometries of residential, populated , and enterprise/industrial areas, streets, train tracks, protected areas and water bodies
polygon_flaeche_ungeeignet_rein <- fl_wid_kat_alle %>%
  filter(kategorie == "wohngebiet" | kategorie == "bewohnt" | 
           kategorie == "betrieb" | kategorie == "gewaeser" | 
           kategorie == "bahn" | kategorie == "strasse") %>%
  select(geometry) %>%
  st_union() %>%
  st_union(wohngebiete_buffer) %>%
  st_union(pa_comb)

# clip the polygon of suitable areas to polygon_flaeche_ungeeignet_rein
polygon_flaeche_geeignet <- st_difference(polygon_flaeche_geeignet_rein, 
                                          polygon_flaeche_ungeeignet_rein)
```

```{r, include = FALSE}
st_write(polygon_flaeche_geeignet, "daten_zwischenablage/polygon_flaeche_geeignet.shp")

polygon_flaeche_geeignet <- st_read("/vsicurl/https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/polygon_flaeche_geeignet.shp")
```

## Auswählen von tauglichen Landbedeckungstypen

```{r, include = FALSE, eval = TRUE}
# load in landcover data for Salzburg
lc_sbg <- rast("daten_zwischenablage/lc_sbg.tif")
```

```{r}
#### ----------------------------- Land Cover ----------------------------- ####
# 10 - Tree Cover
# 20 - Shrublands # suitable
# 30 - Grassland # suitable
# 40 - Cropland # suitable 
# 50 - Built-up
# 60 - Bare/sparse vegetation # suitable
# 70 - Snow and ice
# 80 - Permanent water bodies
# 90 - Herbaceous wetland
# 100 - Moss and lichen

# mask to polygon_flaeche_geeignet 
lc_geeignet_fl <- mask(lc_sbg, polygon_flaeche_geeignet)

# set areas with suitable landcover to 1 and rest to na
lc_geeignet <- subst(lc_geeignet_fl, c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100), 
                     c(NA, 1, 1, 1, NA, 1, NA, NA, NA, NA), others=NA)
```

```{r, include=FALSE}
writeRaster(lc_geeignet, "daten_zwischenablage/lc_geeignet.tif", overwrite = T)

lc_geeignet <- rast("daten_zwischenablage/lc_geeignet.tif")
```

## Topographische Kriterien

```{r, include=FALSE, eval = TRUE}
# load in dgm
dgm <- rast("daten_zwischenablage/dgm.tif")
```

```{r}
#### ----------------------------- Topography ----------------------------- 

# mask the digital elevation model to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
dgm_geeignet_fl <- mask(dgm, polygon_flaeche_geeignet)

# set all cells above 1500 m in dgm_geeignet_fl to NA
dgm_geeignet <- terra::clamp(dgm_geeignet_fl, upper=1500, value=FALSE)
```

```{r, include = FALSE}
writeRaster(dgm_geeignet, "daten_zwischenablage/dgm_geeignet.tif")
```

```{r}
# calculate aspect from the digital elevation model
terra::terrain(dgm, v="aspect", neighbors=8, unit="degrees", filename="daten_zwischenablage/hangrichtung.tif", overwrite = T)

# calculate slope from digital elevation model
terra::terrain(dgm, v="slope", neighbors=8, unit="degrees", filename="daten_zwischenablage/hangneigung.tif", overwrite = T)

# read in data for asepct
hangausrichtung <- rast("daten_zwischenablage/hangausrichtung.tif")

# read in data for slope
hangneigung <- rast("daten_zwischenablage/hangneigung.tif")
```

```{r}
# criteria: slope less than 15 degrees
# mask the slope raster to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
hangneigung_geeignet_fl <- terra::mask(hangneigung, polygon_flaeche_geeignet)

# define values for matrix to set areas with suitable gradient (0-15 degrees) to 1 and rest to na
hangneigung_zahl <- c(0, 15, 1)

# create matrix for re-classification
hangneigung_matr <- matrix(hangneigung_zahl, ncol=3, byrow=TRUE)

# reclassify areas of suitable gradient and set other areas to NA
hangneigung_geeignet_alle <- classify(hangneigung_geeignet_fl,
                                      hangneigung_matr, others=NA)

# define values for matrix to set areas with a gradient lower than 3.5 to 1 and rest to na (to be used in conjunction with aspect data)
hangneigung_zahl_3_5 <- c(0, 3.5, 1)

# create matrix for re-classification
hangneigung_matr_3_5 <- matrix(hangneigung_zahl_3_5, ncol=3, byrow=TRUE)

# reclassify areas meeting gradient criteria and set other areas to NA
hangneigung_geeignet_unter_3_5 <- classify(hangneigung_geeignet_fl,
                                           hangneigung_matr_3_5, others=NA)

# clip hangneigung_geeignet_alle with dgm_geeignet
hn_dgm_geeignet <- terra::mask(hangneigung_geeignet_alle, dgm_geeignet)
```

```{r}
# overall criteria: aspect between 110 - 200 (unless slope is less than 3.5 degrees, then aspect is not taken into account)

# mask the aspect raster to the appropriate areas as determined by the combined polygon buffers (polygon_flaeche_geeignet)
hangausrichtung_geeignet_fl <- terra::mask(hangausrichtung,
                                           polygon_flaeche_geeignet)

# define values for matrix to set areas with an aspect from 110-200 to 1 and rest to na
hangausrichtung_zahl <- c(110, 200, 1)

# create matrix for reclassification
hangausrichtung_matr <- matrix(hangausrichtung_zahl, ncol=3, byrow=TRUE)

# reclassify areas meeting aspect criteria and set other areas to NA
hangausrichtung_geeignet <- classify(hangausrichtung_geeignet_fl,
                                     hangausrichtung_matr, others=NA)

# clip with hn_dgm_geeignet
hn_dgm_ha_geeignet <- terra::mask(hn_dgm_geeignet,
                                  hangausrichtung_geeignet)
```

```{r, include = FALSE}
writeRaster(hn_dgm_ha_geeignet, "daten_zwischenablage/hn_dgm_ha_geeignet.tif")
```

```{r}
# add in those areas under 3.5 degrees of gradient
topographie_geeignet <- terra::merge(hn_dgm_ha_geeignet,
                                     hangneigung_geeignet_unter_3_5)
```

```{r, include = FALSE}
writeRaster(topographie_geeignet, "daten_zwischenablage/topographie_geeignet.tif")
topographie_geeignet <- rast("daten_zwischenablage/topographie_geeignet.tif")
```

## Einbeziehung der Solareinstrahlung

```{r, include=FALSE}
# load in saved resampled raster
solar_resample <- rast("daten_zwischenablage/solar_resample.tif")
```

```{r}
#### --------------------------- Solar Radiation -------------------------- ####
# resample solar_raw to a lower resolution based on dgm (otherwise R does not compute)
# also to allow for more contiguous areas - with 1x1 resolution - there would likely be very fragemetned areas
solar_resample <- resample(solar_raw, dgm)

# set values of areas which do satisfy the 1100 kw/yr requirement to NA
solar_geeignet <- terra::clamp(solar_resample, lower=1100, value=FALSE)
```

```{r, include = FALSE}
# write out raster
writeRaster(solar_geeignet, "daten_zwischenablage/solar_geeignet.tif", overwrite = T)
```

```{r}
#### ------------ Combine solar_geeignet & topographie_geeignet ----------- ####
# mask suitable topographical areas with areas with sufficient solar radiation
# done as these rasters are on the smae grid and at the same resolution
top_solar_geeignet <- terra::mask(topographie_geeignet, solar_geeignet)
```

```{r, include = FALSE}
# write out raster
writeRaster(top_solar_geeignet,"daten_zwischenablage/top_solar_geeignet.tif")
```

## Umwandeln zu SF zum Abbilden

```{r}
#### --------------------------- Convert to sf ---------------------------- ####
# topography-solar combined raster

# force raster to polygon
top_solar_geeignet_vec <- as.polygons(top_solar_geeignet)

# change to sf object and select only geometry
top_solar_geeignet_vec <- st_as_sf(top_solar_geeignet_vec) %>%
  select(geometry)

# lc raster

# force raster to polygon
lc_geeignet_vec <- as.polygons(lc_geeignet)

# change to sf object and select only geometry
lc_geeignet_vec <- st_as_sf(lc_geeignet_vec) %>%
  select(geometry)

# find intersection between solar, topography and lc areas
flaeche_geeignet <- st_intersection(top_solar_geeignet_vec, lc_geeignet_vec)
```

```{r, include = FALSE}
# write out shp
st_write(flaeche_geeignet, "daten_zwischenablage/flaeche_geeignet.shp")
```

```{r, include = FALSE, eval=TRUE}
# read in flaeche_geeignet
flaeche_geeignet <- st_read("daten_zwischenablage/flaeche_geeignet.shp")
```

## Solaranlage in Salzburg - Aktuell und Potenzial

```{r, eval=TRUE, fig.align='center'}
#### -------- Map of Potential Solar Areas and Current Solar Areas -------- ####
# plot map
tm_shape(flaeche_geeignet, bbox = st_bbox(gemeinden_ltw)) + # use gemeinden_ltw bbox as flaeche_geeignet bounding box gets cut off
  # add yellow polygons for areas suitable for solar farms
  tm_polygons(col= "yellow", 
              border.col = "yellow") +
  tm_shape(fl_wid_solar) + 
  # add red polygons for areas suitable for solar farms
  tm_polygons(col= "red", 
              border.col = "red") +
  # add borders of municipalities
  tm_shape(gemeinden_ltw) +
  tm_borders(col="black", 
             lwd=2) + 
  # add legend 
  tm_add_legend(type = c("fill"),
                labels = c("Geeingte Solarfläche", "Bestehende Anlagen"),
                col = c( "yellow", "red"),
                border.lwd = 0) +
  # add title and format legend 
  tm_layout(main.title = "Geeignete Solarfläche und Bestehende Solaranlagen", 
            main.title.fontface = 2, fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", type = 'text', legend.format = list(title.size = 0.1))
```

## Cluster und Hotspot Analyse

```{r, eval=TRUE}
#### ----------- Cluster Analysis and Spatial Autoceorrelation ------------ ####

#### calculate the amount of suitable solar farm area in each municipality ----

# find intersection of suitable solar farm  areas per municipality
gemeinden_solar <- st_intersection(flaeche_geeignet, gemeinden_ltw)

# find the area of suitable solar farm areas per municipality
gemeinden_solar$pot_solar_flaeche <- st_area(gemeinden_solar)

# convert to tibble and select just the area of the suitable solar farm areas and gkz for joining 
gemeinden_solar_df <- as_tibble(gemeinden_solar) %>%
  select(c(gkz, pot_solar_flaeche))

# join with other data on municipalities
gemeinden_voll <- gemeinden_ltw %>%
  left_join(gemeinden_solar_df)
```

```{r}
#### calculate amount of grassland per municipality ----

# set the value of grassland to 1 and everything else to NA
lc_gland <- subst(lc_sbg,c(0, 30), c(NA, 1), others=NA)

# convert sf multipolygon to terra vector
gemeinden_terra <- vect(gemeinden_voll)

# extract raster values for each polygon
gland_pixels <- terra::extract(lc_gland, gemeinden_terra, fun = sum, 
                               na.rm = TRUE)

# add unique identifier from gemeinden_solar to extracted values
gland_pixels$gkz <- gemeinden_voll$gkz

# calculate pixel area
pixel_flaeche <- prod(res(lc_gland))

# convert pixel counts to area
gland_pixels$gruenland_flaeche <- gland_pixels$ESA_WorldCover_10m_2021_v200_N45E012_Map * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
gland_pixels$gruenland_flaeche <- set_units(gland_pixels$gruenland_flaeche,
                                            "m^2") 

# combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(gland_pixels[, c("gkz", "gruenland_flaeche")], by = "gkz")
```

```{r, include=FALSE, eval=TRUE}
#### calculate amount of grassland per municipality ----

gland_pixels <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/gland_pixels.csv")

# Add unique identifier from gemeinden_solar to extracted values
gland_pixels$gkz <- gemeinden_voll$gkz

# Calculate pixel area
pixel_flaeche <- prod(res(lc_sbg))

# Convert pixel counts to area
gland_pixels$gruenland_flaeche <- gland_pixels$ESA_WorldCover_10m_2021_v200_N45E012_Map * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
gland_pixels$gruenland_flaeche <- set_units(gland_pixels$gruenland_flaeche,
                                          "m^2") 

# Combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(gland_pixels[, c("gkz", "gruenland_flaeche")], by = "gkz")
```

```{r, eval=TRUE}
#### Calculate the amount of populated area per municipality ----

# initiate vector to store data on populated area per municipality
bewohnte_flaeche_pro_gemeinde <- c()

# calculate the populated area within each municipality
for (i in 1:nrow(gemeinden_voll)) { 
  
  bewohnte_flaeche_pro_gemeinde[i] <- st_intersection(fl_wid_bewohnt, gemeinden_voll$geometry[i]) %>%
  st_union() %>%
  st_area()
}

# add this to gemeinden_voll
gemeinden_voll <- gemeinden_voll %>%
  add_column(bewohnte_flaeche = bewohnte_flaeche_pro_gemeinde)

# add units of metres squared
gemeinden_voll$bewohnte_flaeche <-  set_units(gemeinden_voll$bewohnte_flaeche,"m^2")
```

```{r}
#### Calculate amount of mountain area per municipality ----

# define values for matrix to set areas above 1500 m to 1 and rest to na
dgm_1500_zahl <- c(1500, Inf, 1)

# create matrix for re-classification
dgm_1500_matr <- matrix(dgm_1500_zahl, ncol=3, byrow=TRUE)

# reclassify areas under 1500 m to NA
dgm_1500 <- classify(dgm, dgm_1500_matr, others=NA)

# extract raster values for each polygon
dgm_pixels <- terra::extract(dgm_1500, gemeinden_terra, fun = sum, na.rm = TRUE)

# add unique identifier from gemeinden_voll to extracted values
dgm_pixels$gkz <- gemeinden_voll$gkz

# calculate pixel area
pixel_flaeche <- prod(res(dgm_1500))

# convert pixel counts to area
dgm_pixels$berg_flaeche <- dgm_pixels$dgm5m * pixel_flaeche

# add units to gland_pixel$berg_flaeche
dgm_pixels$berg_flaeche <- set_units(dgm_pixels$berg_flaeche,
                                    "m^2") 
# replace na values with 0
dgm_pixels$berg_flaeche[is.na(dgm_pixels$berg_flaeche)] <- 0

# combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(dgm_pixels[, c("gkz", "berg_flaeche")], by = "gkz")
```

```{r, include=FALSE, eval=TRUE}
#### Calculate amount of mountain area per municipality ----
dgm_pixels <- read_csv("https://raw.githubusercontent.com/tyls-27/solar_salzburg/master/daten_zwischenablage/dgm_pixels.csv")

# Add unique identifier from gemeinden_solar to extracted values
dgm_pixels$gkz <- gemeinden_voll$gkz

# Calculate pixel area
pixel_flaeche <- prod(res(dgm))

# Convert pixel counts to area
dgm_pixels$berg_flaeche <- dgm_pixels$dgm5m * pixel_flaeche

# add units to gland_pixel$gruenland_flaeche
dgm_pixels$berg_flaeche <- set_units(dgm_pixels$berg_flaeche,
                                    "m^2") 
# replace na values with 0
dgm_pixels$berg_flaeche[is.na(dgm_pixels$berg_flaeche)] <- 0

# Combine the extracted values with the data on the municipalities
gemeinden_voll <- gemeinden_voll %>%
  left_join(dgm_pixels[, c("gkz", "berg_flaeche")], by = "gkz")
```

```{r, eval=TRUE}
#### Calculate proportions of appropriate solar farm areas, grassland and populated areas per municipality in terms of their total area ----

gemeinden_data <- gemeinden_voll %>%
  # calculate area of each municipality and mutate to tibble
  mutate(flaeche = st_area(geometry)) %>%
  # calculate the percentage of potential solar farm, grassland, populated and mountain areas per municipality and mutate it to tibble
  mutate(solar_anteil = 
           as.numeric(pot_solar_flaeche)/as.numeric(flaeche) * 100,
         gruenland_anteil =
           as.numeric(gruenland_flaeche)/as.numeric(flaeche) * 100,
         bewohnt_anteil = as.numeric(bewohnte_flaeche)/as.numeric(flaeche) * 100,
         berg_anteil = as.numeric(berg_flaeche)/as.numeric(flaeche)) %>%
  # remove the shape_area and shape_len columns
  dplyr::select(-c(shape_area, shape_len)) %>%
  # rearrange order of columns 
  relocate(geometry, .after = last_col()) %>%
  relocate(solar_anteil, .after = pot_solar_flaeche) %>%
  relocate(gruenland_anteil, .after = gruenland_flaeche) %>%
  relocate(bewohnt_anteil, .after = bewohnte_flaeche) %>%
  relocate(berg_anteil, .after = berg_flaeche) %>%
  # calculate the population density in km2 and mutate to tibble
  mutate(einwohnerzahl_pro_qkm = bevoelkerung/as.numeric(set_units(flaeche, "km^2")), .after = bevoelkerung) %>%
  # transform back to sf object
  st_as_sf()
```

### Interaktive Karte
```{r, eval = TRUE}
#### ---------------------------- Leaflet Map ----------------------------- ####
# transform layers to 4326 for plotting
flaeche_geeignet_4326 <- st_transform(flaeche_geeignet, "EPSG: 4326")
fl_wid_solar_4326 <- st_transform(fl_wid_solar, "EPSG: 4326")
fl_wid_bewohnt_4326 <- st_transform(fl_wid_bewohnt, "EPSG: 4326")
pa_comb_4326 <- st_transform(pa_comb, "EPSG: 4326")
gemeinden_data_4326 <- st_transform(gemeinden_data, "EPSG: 4326")
bezirk_grenz_4326 <- st_transform(bezirk_grenz, "EPSG: 4326")
```
```{r, eval = TRUE}
# create basemap
basemap <- leaflet() %>% 
  setView(lng = 13, lat = 47.5, zoom = 8.4) %>%
  # add different provider tiles
  addProviderTiles(
    "OpenStreetMap",
    # give the layer a name
    group = "OpenStreetMap"
  ) %>%
  addProviderTiles(
    "CartoDB.Positron",
    group = "CartoDB.Positron"
  ) %>%
  addProviderTiles(
    "Esri.WorldTopoMap",
    group = "Esri.WorldTopoMap"
  ) %>%
  addProviderTiles(
    "Esri.WorldImagery",
    group = "Esri.WorldImagery"
  ) %>%
  addProviderTiles(
    "Esri.WorldTerrain",
    group = "Esri.WorldTerrain"
  ) %>%
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap","CartoDB.Positron", "Esri.WorldTopoMap",
      "Esri.WorldImagery", "Esri.WorldTerrain"
    ),
    # position it on the topleft
    position = "topleft"
  )

# plot map 
basemap %>%
  addPolygons(
    data = bezirk_grenz_4326,
    stroke = TRUE,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 2,
    fillColor = "whitesmoke",
    # set the fill opacity
    fillOpacity = 0.3,
    group = "Bezirke",
    popup = paste("<b>Bezirk</b> ", "<br>", bezirk_grenz_4326$PB),
    highlightOptions = highlightOptions(color = "black", weight = 4, bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = fl_wid_solar_4326,
    # set the color of the polygon
    color = "red",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    # set the fill opacity
    fillColor = "red",
    fillOpacity = 0.6,
    group = "Bestehende Solaranlagen"
  ) %>%
  
  addPolygons(
    data = flaeche_geeignet_4326,
    # set the color of the polygon
    color = "yellow",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "yellow",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Geeignete Solarfläche"
  ) %>%
  
  addPolygons(
    data = pa_comb_4326,
    # set the color of the polygon
    color = "green",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "green",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Schutzgebiete"
  ) %>%
  addPolygons(
    data = fl_wid_bewohnt_4326,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "black",
    # set the fill opacity
    fillOpacity = 0.6,
    group = "Bewohnte Gebiete"
  ) %>%
  addPolygons(
    data = gemeinden_data_4326,
    stroke = TRUE,
    # set the color of the polygon
    color = "black",
    # set the opacity of the outline
    opacity = 1,
    # set the stroke width in pixels
    weight = 1,
    fillColor = "grey",
    # set the fill opacity
    fillOpacity = 0,
    group = "Gemeinden",
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  gemeinden_data_4326$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Bevölkerung</br> ",
                  "<br><b>Einwohnerzahl:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  gemeinden_data_4326$bevoelkerung,
                  "<br><b>Bevölkerungsdichte:</b> ", 
                  format(round(gemeinden_data_4326$einwohnerzahl_pro_qkm, 3), 
                         nsmall = 3), "Einwohner/km","<br>", 
                  "<br><b>Solar</br> ",
                  "<br><b>Geeignete Solarfläche (Absolut):</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(set_units(gemeinden_data_4326$pot_solar_flaeche,
                                         km^2), 3), nsmall = 3),
                  "<br><b>Geeignete Solarfläche (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$solar_anteil, 3), 
                         nsmall = 3), "%", "<br>", "<br><b>Landnutzung</br> ",
                  "<br><b>Grünland (Anteil):</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(gemeinden_data_4326$gruenland_anteil, 3), nsmall = 3),
                  "%","<br><b>Bewohnte Gebiete (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$bewohnt_anteil, 3), nsmall = 3), 
                  "%", "<br><b>Bergfläche (Anteil):</b> ", 
                  format(round(gemeinden_data_4326$berg_anteil, 3), nsmall = 3), 
                  "%"),
    highlightOptions = highlightOptions(color = "black", weight = 4, bringToFront = TRUE)
  ) %>%
  # add a layers control
  addLayersControl(
    baseGroups = c(
      "OpenStreetMap","CartoDB.Positron", "Esri.WorldTopoMap",
      "Esri.WorldImagery", "Esri.WorldTerrain"
    ),
    overlayGroups = c("Bezirke", "Gemeinden", "Bestehende Solaranlagen", 
                      "Geeignete Solarfläche", "Schutzgebiete", 
                      "Bewohnte Gebiete"),
    # position it on the top left
    position = "topleft"
  )

```

### Hotspot Analyse und Räumliche Autocorrelation

```{r, eval=TRUE, fig.align='center'}
#### Spatial autocorrelation ----

#### Calculate spatial autocorrelation of potential solar farm areas, grassland, populated areas and mountainous areas

#create centroids and join neighbours within 20,000 m so that every municipality has a neighbour
gemeinde_nachbarn <- dnearneigh(st_geometry(st_centroid(gemeinden_data)), 0, 20000)

# create a neighbours list
gemeinde_nachbarn_gewichte<- gemeinde_nachbarn %>% 
  nb2listw(., style = "B")

# create sf df with centroids of each municipality
gemeinde_zentroide <- gemeinden_data %>% 
  st_centroid()

# plot neighbours using centroids
plot(gemeinde_nachbarn_gewichte, st_geometry(gemeinde_zentroide), col = "green", pch = 20, cex = 0.5)
```

```{r, eval=TRUE}
#create GI-Statistics for absolute values on potential solar farm areas
GI_solar_absolut <- gemeinden_data %>%
  pull(pot_solar_flaeche) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on potential solar farm areas
GI_solar_relativ <- gemeinden_data %>%
  pull(solar_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on grassland areas
GI_gland_relativ <- gemeinden_data %>%
  pull(gruenland_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on populated areas
GI_bewohnt_relativ <- gemeinden_data %>%
  pull(bewohnt_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()

#create GI-Statistics for relative values on mountain areas
GI_berg_relativ <- gemeinden_data %>%
  pull(berg_anteil) %>%
  as.vector()%>%
  localG(., gemeinde_nachbarn_gewichte) %>%
  as.numeric()
```

```{r, eval=TRUE}
# join the local Gi* statistics to the names, gkz and geometry column of the gemeinden_data spatial dataframe
gemeinden_GI <- gemeinden_data %>% 
  select(c(1,2,5, 23:31)) %>%
  add_column(gi_solar_absolut = GI_solar_absolut,
         gi_solar_relativ = GI_solar_relativ,
         gi_gland_relativ = GI_gland_relativ,
         gi_bewohnt_relativ = GI_bewohnt_relativ,
         gi_berg_relativ = GI_berg_relativ) %>%
  relocate(geometry, .after = last_col()) %>% 
  st_as_sf() 
 
# Convert units to kn^2 of potential solar farm areas
gemeinden_GI$pot_solar_flaeche <- set_units(gemeinden_GI$pot_solar_flaeche, "km^2") 
```

```{r, eval=TRUE}
#### Chloropeth Maps and GI Maps

# create colour palettes for chloropeth maps
solar_palette <- rev(heat.colors(8))
gland_palette <- brewer.pal(8, "Greens")
bewohnt_palette <- brewer.pal(8, "Blues")
berg_palette <- brewer.pal(8, "Greys")

# create a color ramp function
farben_hotspot <- colorRampPalette(c("blue", "white","red"))

# create a colour palette for autocorrelation maps
GIFarben <- farben_hotspot(13)
```

```{r, eval=TRUE, fig.align='center'}
# solar absolute - chloropeth
sol_abs_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the solar_palette to reflect the amount of suitable solar areas in each municipality
  tm_fill("pot_solar_flaeche", 
          title = "Fläche\n(Quadratlkilometer)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = solar_palette, border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (absolut)\n ", 
            main.title.fontface = 2, 
            fontfamily = "Arial", 
            main.title.size =1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich",
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Solar absolute - GI Map
sol_abs_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of suitable solar areas (absolute) per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_solar_absolut", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-3, -2, -1, 0, 1, 2, 3, 4, 5, 6),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
    # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (absolut)\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size =1.2, 
            legend.outside = TRUE, 
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  tm_shape(gemeinden_GI) + 
  tm_borders(col="black", lwd=2) +
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

sol_abs_komb_karte <- tmap_arrange(sol_abs_karte, sol_abs_gi_karte)

sol_abs_komb_karte

```

```{r, eval=TRUE, fig.align='center'}
# Solar relative - chloropeth map
sol_rel_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the solar_palette to reflect the percentage of land that is suitable for solar farms in each municipality
  tm_fill("solar_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "jenks",
          textNA = "No data",
          colorNA = "white", 
          palette = solar_palette, 
          border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (relativ)\n ", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Solar relative - GI Map
sol_rel_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of suitable solar areas per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_solar_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add borders of the municipalities
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Geeignete Solarfläche (relativ)\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 0.75, 
            legend.title.fontface = 2,
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

sol_rel_comb_karte <- tmap_arrange(sol_rel_karte, sol_rel_gi_karte)

sol_rel_comb_karte
```

```{r, eval=TRUE, fig.align='center'}
# Grassland relative - chloropeth map
gland_karte <-tm_shape(gemeinden_GI) +
  # fill the geometries using the gland_palette to reflect the percentage of grassland cover in each municipality
  tm_fill("gruenland_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = gland_palette, border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title 
  tm_layout(main.title = "Grünland (relativ)", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Grassland - GI map
gland_gi_karte <- tm_shape(gemeinden_GI) +
  # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of grassland cover per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_gland_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Grünland - Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

gland_komb_karte <- tmap_arrange(gland_karte, gland_gi_karte)

gland_komb_karte
```

```{r, eval=TRUE, fig.align='center'}
# Populated relative - chloropeth map
bewohnt_karte <-tm_shape(gemeinden_GI) +
  # fill the geometries using the bewohnt_palette to reflect the percentage of populated land in each municipality
  tm_fill("bewohnt_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "jenks",
          textNA = "No data",
          colorNA = "white", 
          palette = bewohnt_palette, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Bewohnte Gebiete (relativ)\n ", 
            main.title.fontface = 2, 
            fontfamily = "Arial", 
            main.title.size = 1.2, 
            legend.outside = TRUE, 
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size= 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Populated areas - GI map
bewohnt_gi_karte <- tm_shape(gemeinden_GI) +
    # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of populated area per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_bewohnt_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed",
          breaks = c(-2, -1, 0, 1, 2, 3, 4, 5, 6),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders 
  tm_borders(col="black", 
             lwd=2) +
  # add legend and title
  tm_layout(main.title = "Bewohnte Gebiete\n- Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

bewohnt_komb_karte <- tmap_arrange(bewohnt_karte, bewohnt_gi_karte)

bewohnt_komb_karte
```

```{r, eval=TRUE, fig.align='center'}
# Mountains relative - chloropeth map
berge_karte <-tm_shape(gemeinden_GI) +
    # fill the geometries using the berg_palette to reflect the percentage of mountainous area (> 1500 m) in each municipality
  tm_fill("berg_anteil", 
          title = "Abdeckung pro\nGemeinde (%)",
          style = "pretty",
          textNA = "No data",
          colorNA = "white", 
          palette = berg_palette, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) + 
  # add legend and title
  tm_layout(main.title = "Berge (relativ)", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F,
            legend.format = list(text.separator="-")) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

# Mountainous areas - GI map
berge_gi_karte <-tm_shape(gemeinden_GI) +
    # fill the geometries using the GIFarben to reflect the spatial hotspots of the proportion of mountainous area (> 1500 m) per municipality based on z-number derived from Getis-Ord (GI*) 
  tm_fill("gi_berg_relativ", 
          title = "Gi (Z-Wert)",
          style = "fixed", 
          breaks = c(-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5),
          midpoint = 0,
          textNA = "No data",
          colorNA = "white", 
          palette = GIFarben, 
          border.col = "black")+
  # add municipality borders
  tm_borders(col="black", 
             lwd=2) +
  # add legend and title
  tm_layout(main.title = "Berge - Hotspot Analyse", 
            main.title.fontface = 2,
            fontfamily = "Arial",
            main.title.size = 1.2, 
            legend.outside = TRUE,
            legend.text.size = 0.75, 
            legend.title.size = 0.75, 
            legend.title.fontface = 2, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", 
             text.size = 0.75, 
             size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), 
               text.size = 0.75,
               position = c(0, 0.2))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich", 
                type = 'text', 
                legend.format = list(title.size = 0.1))

berge_komb_karte <- tmap_arrange(berge_karte, berge_gi_karte)

berge_komb_karte
```

### Cluster Analyse

```{r, eval=TRUE}
#### Cluster analysis ----

# select municipality name, gkz, population and relative coverage columns
gemeinden_clus <- gemeinden_data %>% 
  as_tibble() %>%
  dplyr::select(c(1:2, 4, 25, 27, 29, 31, 33)) %>%
  # scale clustering columns
  mutate_at(c(3:7), ~(scale(.) %>% as.vector)) %>% 
  # rename rows as municipality names
  column_to_rownames("gemeindename") 
```

```{r, eval=TRUE}
# use elbow method to determine number of clusters
fviz_nbclust(gemeinden_clus[,2:6], kmeans, method = "wss")
```

```{r, eval=TRUE}
# create clusters based on elbow method - 3 clusters
clusters <- kmeans(gemeinden_clus[,2:6], centers=3, nstart=25)

# view cluster features
clusters
```

```{r, eval=TRUE}
# visualise clusters graphically - maybe don't need when have map?
fviz_cluster(clusters, data = gemeinden_clus[,2:6])
```

```{r, eval=TRUE, fig.align='center'}
# Mapping clusters

# Add clusters to gemeinden_clus df
gemeinden_clus <- gemeinden_clus %>%
  mutate(cluster = clusters$cluster, .after = berg_anteil) %>%
  st_as_sf() # force to sf for plotting

# plotting code
tm_shape(gemeinden_clus) + 
  # fill geometries based on the cluster assigned
  tm_fill(col = "cluster", 
          style = "cat", 
          palette = c("orange", "navy", "whitesmoke"),
          legend.show = F) + 
  # add municipality borders
  tm_borders(col = "black", 
             lwd = 2) +
  # add legend
  tm_add_legend(col = c("Orange", "darkblue", "grey"), 
                labels = c("1", "2", "3"),
                title = "Clusters") +
  # add title
  tm_layout(main.title = "Merkmale der Gemeinden", 
            main.title.fontface = 2,fontfamily = "Arial",main.title.size =
              1.2, 
            legend.outside = TRUE,legend.text.size = 0.75, 
            legend.position = c("left","top"), 
            legend.title.size = 1.5, 
            legend.title.fontface = 1.5, 
            frame = F) + 
  # add North arrow
  tm_compass(type = "arrow", text.size = 0.75, size = 1.3,
             position = c("right", "top")) + 
  # add scale bar
  tm_scale_bar(breaks = c(0, 10, 20, 30, 40, 50), text.size=0.75,
               position = c(0, -0.02))+
  # add credits
  tm_add_legend(title = "Projektion: MGI / Austria GK M31\nDaten: Land Salzburg, OGD\nÖsterreich, ESA", type = 'text', legend.format = list(title.size = 0.1))
```

```{r, eval=TRUE}
#### Statistically explore the relationship between these variables ----

# build a linear model based
fit <- lm(solar_anteil ~ gruenland_anteil + bewohnt_anteil + berg_anteil + einwohnerzahl_pro_qkm, gemeinden_data)

# look at fit of linear model
summary(fit)
```

## Politische Durchführbarkeit
```{r, eval=TRUE}
#### ---------------------------- Election Map ---------------------------- ####

# select data from gemeinden_data on elections and add a row containing strongest party in each municipality
ltw_geo <- gemeinden_data %>%
  select(c(1:2, 15:22, 33)) %>%
  rename_with(~str_remove(., "_prozent"), ends_with("_prozent")) %>%
  rename(Gruene = GRUENE) %>%
  rowwise() %>%
  mutate(staerkste_partei = names(.)[which.max(c_across(3:10))+2], .after = MFG)

# create function to calculate winning margin of winning party in each municipality
gewinspanne_func <- function(reihe) {
  reihe_sortiert <- sort(as.numeric(reihe), decreasing = TRUE)
  differenz <- reihe_sortiert[1] - reihe_sortiert[2]
  return(differenz)
}

# add a row to ltw_geo with the winning margin of winning party in each municipality
ltw_geo$gewinnspanne <- apply(ltw_geo[, -c(1:2, (ncol(ltw_geo) - 1):ncol(ltw_geo))], 1, gewinspanne_func)

# reorder columns and add columns for each winning party and their winning margins
ltw_geo <- ltw_geo %>%
  select(c(1:11, 13, 12)) %>%
  mutate(OeVP_gemeinden = ifelse(staerkste_partei == "OeVP", gewinnspanne, NA),
         FPOe_gemeinden = ifelse(staerkste_partei == "FPOe", gewinnspanne, NA),
         SPOe_gemeinden = ifelse(staerkste_partei == "SPOe", gewinnspanne, NA),
         .after = staerkste_partei)
```

Hier verlieren wir Informationen über die Parteien, die keinen ersten Platz in
einer Gemeinde erzielen.

```{r, eval=TRUE}
# transform layers to 4326 for plotting
ltw_geo_4326 <- st_transform(ltw_geo, "EPSG: 4326")

# create three new dataframes for the winning parties
oevp <- ltw_geo_4326 %>% 
  filter(complete.cases(OeVP_gemeinden))

fpoe <- ltw_geo_4326 %>% 
  filter(complete.cases(FPOe_gemeinden))

spoe <- ltw_geo_4326 %>% 
  filter(complete.cases(SPOe_gemeinden))


# create palette to display party winning margins
min_max_werte <- range(ltw_geo$gewinnspanne, na.rm = TRUE)
oevp_palette <- colorNumeric(palette = "Greys", 
                              domain=c(min_max_werte[1], min_max_werte[2]))
fpoe_palette <- colorNumeric(palette = "Blues", 
                                domain=c(min_max_werte[1], min_max_werte[[2]]))
spoe_palette <- colorNumeric(palette = "Reds", 
                              domain=c(min_max_werte[1], min_max_werte[2]))
```

```{r, eval=TRUE}
leaflet() %>%
  setView(lng = 13.5, lat = 47.5, zoom = 8.4) %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(
    data = oevp,
    fillColor = ~oevp_palette(oevp$OeVP_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1,
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  oevp$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(oevp$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(oevp$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(oevp$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(oevp$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(oevp$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(oevp$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(oevp$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(oevp$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = fpoe,
    fillColor = ~fpoe_palette(fpoe$FPOe_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1,
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  fpoe$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(fpoe$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(fpoe$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(fpoe$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(fpoe$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(fpoe$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(fpoe$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(fpoe$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(fpoe$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addPolygons(
    data = spoe,
    fillColor = ~spoe_palette(spoe$SPOe_gemeinden),
    stroke = TRUE,
    smoothFactor = 0.2,
    fillOpacity = 1,
    color = "#666",
    weight = 1, 
    popup = paste("<b><span style='font-weight: bold;'>",
                  "<div style='text-align: center;'>",
                  spoe$gemeindename, 
                  "<div style='text-align: left;'>",
                  "<br><b>Landtagswahlergebnisse 2023</br> ",
                  "<br><b>ÖVP:</b> ", 
                  "<b><span style='font-weight: normal;'>",
                  format(round(spoe$OeVP, 3), nsmall = 3), 
                  "%",
                  "<br><b>SPÖ:</b> ", 
                  format(round(spoe$SPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>FPÖ:</b> ", 
                  format(round(spoe$FPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Die Grünen:</b> ", 
                  format(round(spoe$Gruene, 3), nsmall = 3), 
                  "%",
                  "<br><b>NEOS:</b> ",
                  format(round(spoe$NEOS, 3), nsmall = 3), 
                  "%",
                  "<br><b>KPÖ:</b> ", 
                  format(round(spoe$KPOe, 3), nsmall = 3), 
                  "%",
                  "<br><b>Wir Sind Salzburg:</b> ", 
                  format(round(spoe$WIRS, 3), nsmall = 3), 
                  "%",
                  "<br><b>MFG:</b> ",
                  format(round(spoe$MFG, 3), nsmall = 3), 
                  "%"),
                  highlightOptions = highlightOptions(color = "black", weight = 4,
                                                      bringToFront = TRUE)
  ) %>%
  addLegendNumeric(pal = spoe_palette, values = ~min_max_werte, title = "SPÖ
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = spoe) %>%
  addLegendNumeric(pal = fpoe_palette, values = ~min_max_werte, title = "FPÖ
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = fpoe) %>%
  addLegendNumeric(pal = oevp_palette, values = ~min_max_werte, title = "ÖVP
                   Gewinspanne (%)",
                   orientation = 'horizontal', fillOpacity = 1, width = 150,
                   height = 20, position = 'bottomright', data = oevp)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

